var app = (function (exports) {
  'use strict';

  function getExtendedContext(canvas) {
    const haveCanvas = canvas instanceof Element;
    if (!haveCanvas || canvas.tagName.toLowerCase() !== "canvas") {
      throw Error("ERROR in yawgl.getExtendedContext: not a valid Canvas!");
    }

    // developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
    //   #Take_advantage_of_universally_supported_WebGL_1_extensions
    const universalExtensions = [
      "ANGLE_instanced_arrays",
      "EXT_blend_minmax",
      "OES_element_index_unit",
      "OES_standard_derivatives",
      "OES_vertex_array_object",
      "WEBGL_debug_renderer_info",
      "WEBGL_lose_context"
    ];

    // Get a WebGL context, and extend it
    const gl = canvas.getContext("webgl");
    universalExtensions.forEach(ext => getAndApplyExtension(gl, ext));

    // Modify the shaderSource method to add a preamble
    const SHADER_PREAMBLE = `
#extension GL_OES_standard_derivatives : enable
#line 1
`;
    const shaderSource = gl.shaderSource;
    gl.shaderSource = function(shader, source) {
      const modified = (source.indexOf("GL_OES_standard_derivatives") < 0)
        ? SHADER_PREAMBLE + source
        : source;
      shaderSource.call(gl, shader, modified);
    };

    return gl;
  }

  function getAndApplyExtension(gl, name) {
    // https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html
    const ext = gl.getExtension(name);
    if (!ext) return null;

    const fnSuffix = name.split("_")[0];
    const enumSuffix = '_' + fnSuffix;

    for (const key in ext) {
      const value = ext[key];
      const isFunc = typeof value === 'function';
      const suffix = isFunc ? fnSuffix : enumSuffix;
      let name = key;
      // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc
      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }
      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          console.warn("conflict:", name, gl[name], value, key);
        }
      } else if (isFunc) {
        gl[name] = (function(origFn) {
          return function() {
            return origFn.apply(ext, arguments);
          };
        })(value);
      } else {
        gl[name] = value;
      }
    }

    return ext;
  }

  function initView(porthole, fieldOfView) {
    // The porthole is an HTML element acting as a window into a 3D world
    // fieldOfView is the vertical view angle range in degrees (floating point)

    // Compute values for transformation between the 3D world and the 2D porthole
    var portRect, width, height, aspect;
    var tanFOV = Math.tan(fieldOfView * Math.PI / 180.0 / 2.0);
    const maxRay = [];

    computeRayParams(); // Set initial values

    return {
      element: porthole, // Back-reference
      changed: computeRayParams,

      width: () => width,
      height: () => height,
      topEdge: () => maxRay[1],   // tanFOV
      rightEdge: () => maxRay[0], // aspect * tanFOV
      maxRay, // TODO: is it good to expose local state?
      getRayParams,
    };

    function computeRayParams() {
      // Compute porthole size
      portRect = porthole.getBoundingClientRect();
      let newWidth = portRect.right - portRect.left;
      let newHeight = portRect.bottom - portRect.top;

      // Exit if no change
      if (width === newWidth && height === newHeight) return false;

      // Update stored values
      width = newWidth;
      height = newHeight;
      aspect = width / height;
      maxRay[0] = aspect * tanFOV;
      maxRay[1] = tanFOV; // Probably no change, but it is exposed externally

      // Let the calling program know that the porthole changed
      return true;
    }

    // Convert a position on the screen into tangents of the angles
    // (relative to screen normal) of a ray shooting off into the 3D space
    function getRayParams(rayVec, clientX, clientY) {
      // NOTE strange behavior of getBoundingClientRect()
      // rect.left and .top are equal to the coordinates given by clientX/Y
      // when the mouse is at the left top pixel in the box.
      // rect.right and .bottom are NOT equal to clientX/Y at the bottom
      // right pixel -- they are one more than the clientX/Y values.
      // Thus the number of pixels in the box is given by 
      //    porthole.clientWidth = rect.right - rect.left  (NO +1 !!)
      var x = clientX - portRect.left;
      var y = portRect.bottom - clientY - 1; // Flip sign to make +y upward

      // Normalized distances from center of box. We normalize by pixel DISTANCE
      // rather than pixel count, to ensure we get -1 and +1 at the ends.
      // (Confirm by considering the 2x2 case)
      var xratio = 2 * x / (width - 1) - 1;
      var yratio = 2 * y / (height - 1) -1;

      rayVec[0] = xratio * maxRay[0];
      rayVec[1] = yratio * maxRay[1];
      //rayVec[2] = -1.0;
      //rayVec[3] = 0.0;
      return;
    }
  }

  function initFramebuffer(gl, width, height) {
    // 1. Create a texture of the desired size
    const target = gl.TEXTURE_2D;
    const level = 0;
    const format = gl.RGBA;
    const type = gl.UNSIGNED_BYTE;
    const border = 0;

    const texture = gl.createTexture();
    gl.bindTexture(target, texture);

    gl.texImage2D(target, level, format, width, height, border,
      format, type, null);

    // Set up for no mipmaps
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);

    // 2. Create a framebuffer and attach the texture
    const buffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
      target, texture, level);

    gl.bindTexture(target, null);

    return {
      buffer,
      size: { width, height },
      sampler: texture,
    };
  }

  function createUniformSetters(gl, program) {
    // Very similar to greggman's module:
    // webglfundamentals.org/docs/module-webgl-utils.html#.createUniformSetters

    // Track texture bindpoint index in case multiple textures are required
    var textureUnit = 0;

    const uniformSetters = {};
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (let i = 0; i < numUniforms; i++) {
      let uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) break;

      let { name, type, size } = uniformInfo;
      let loc = gl.getUniformLocation(program, name);

      // getActiveUniform adds a suffix to the names of arrays
      let isArray = (name.slice(-3) === "[0]");
      let key = (isArray)
        ? name.slice(0, -3)
        : name;

      uniformSetters[key] = createUniformSetter(loc, type, isArray, size);
    }

    return uniformSetters;

    // This function must be nested to access the textureUnit index
    function createUniformSetter(loc, type, isArray, size) {
      switch (type) {
        case gl.FLOAT:
          return (isArray)
            ? (v) => gl.uniform1fv(loc, v)
            : (v) => gl.uniform1f(loc, v);
        case gl.FLOAT_VEC2:
          return (v) => gl.uniform2fv(loc, v);
        case gl.FLOAT_VEC3:
          return (v) => gl.uniform3fv(loc, v);
        case gl.FLOAT_VEC4:
          return (v) => gl.uniform4fv(loc, v);
        case gl.INT:
          return (isArray)
            ? (v) => gl.uniform1iv(loc, v)
            : (v) => gl.uniform1i(loc, v);
        case gl.INT_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.INT_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.INT_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.BOOL:
          return (v) => gl.uniform1iv(loc, v);
        case gl.BOOL_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.BOOL_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.BOOL_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.FLOAT_MAT2:
          return (v) => gl.uniformMatrix2fv(loc, false, v);
        case gl.FLOAT_MAT3:
          return (v) => gl.uniformMatrix3fv(loc, false, v);
        case gl.FLOAT_MAT4:
          return (v) => gl.uniformMatrix4fv(loc, false, v);
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          var bindPoint = getBindPointForSamplerType(gl, type);
          if (isArray) {
            var units = Array.from(Array(size), () => textureUnit++);
            return function(textures) {
              gl.uniform1iv(loc, units);
              textures.forEach( function(texture, index) {
                gl.activeTexture(gl.TEXTURE0 + units[index]);
                gl.bindTexture(bindPoint, texture);
              });
            };
          } else {
            var unit = textureUnit++;
            return function(texture) {
              gl.uniform1i(loc, unit);
              gl.activeTexture(gl.TEXTURE0 + unit);
              gl.bindTexture(bindPoint, texture);
            };
          }
       default:  // we should never get here
          throw("unknown type: 0x" + type.toString(16));
      }
    }
  }

  function getBindPointForSamplerType(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;
    return undefined;
  }

  function setUniforms(setters, values) {
    Object.entries(values).forEach(([key, val]) => {
      var setter = setters[key];
      if (setter) setter(val);
    });
  }

  function getVao(gl, program, attributeState) {
    const { attributes, indices } = attributeState;

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    Object.entries(attributes).forEach(([name, a]) => {
      var index = gl.getAttribLocation(program, name);
      if (index < 0) return;

      gl.enableVertexAttribArray(index);
      gl.bindBuffer(gl.ARRAY_BUFFER, a.buffer);
      gl.vertexAttribPointer(
        index, // index of attribute in program
        a.numComponents || a.size, // Number of elements to read per vertex
        a.type || gl.FLOAT, // Type of each element
        a.normalize || false, // Whether to normalize it
        a.stride || 0, // Byte spacing between vertices
        a.offset || 0 // Byte # to start reading from
      );
      gl.vertexAttribDivisor(index, a.divisor || 0);
    });

    if (indices) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices.buffer);

    gl.bindVertexArray(null);
    return vao;
  }

  function initProgram(gl, vertexSrc, fragmentSrc) {
    const program = gl.createProgram();
    gl.attachShader(program, loadShader(gl, gl.VERTEX_SHADER, vertexSrc));
    gl.attachShader(program, loadShader(gl, gl.FRAGMENT_SHADER, fragmentSrc));
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      fail("Unable to link the program", gl.getProgramInfoLog(program));
    }

    const uniformSetters = createUniformSetters(gl, program);

    function constructVao(attributeState) {
      return getVao(gl, program, attributeState);
    }

    function setupDraw({ uniforms, vao }) {
      gl.useProgram(program);
      setUniforms(uniformSetters, uniforms);
      gl.bindVertexArray(vao);
    }

    return { gl, constructVao, setupDraw };
  }

  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      let log = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      fail("An error occured compiling the shader", log);
    }

    return shader;
  }

  function fail(msg, log) {
    throw Error("yawgl.initProgram: " + msg + ":\n" + log);
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });

  function color_formatHex() {
    return this.rgb().formatHex();
  }

  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }

  function color_formatRgb() {
    return this.rgb().formatRgb();
  }

  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));

  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }

  function rgb_formatRgb() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }

  function initTransform(framebufferSize) {
    const m = new Float64Array(9);
    reset();

    function reset() {
      let { width, height } = framebufferSize;

      // Default transform maps [0, 0] => [-1, 1] and [width, height] => [1, -1]
      // NOTE WebGL column-ordering!
      m[0] = 2 / width;
      m[1] = 0;
      m[2] = 0;
      m[3] = 0;
      m[4] = -2 / height;
      m[5] = 0;
      m[6] = -1;
      m[7] = 1;
      m[8] = 1;
    }

    function set(a, b, c, d, e, f) {
      // TODO: Resize canvas to displayed size?
      reset();
      multiply(m, m, [a, b, 0, c, d, 0, e, f, 1]);
    }

    function transform(a, b, c, d, e, f) {
      multiply(m, m, [a, b, 0, c, d, 0, e, f, 1]);
    }

    return {
      matrix: m,
      set,
      transform,
      translate: (tx, ty) => transform(1, 0, 0, 1, tx, ty),
      scale: (sx, sy) => transform(sx, 0, 0, sy, 0, 0),
      get: () => m.slice(),
    };
  }

  var fillVertexSrc = `precision highp float;
attribute vec2 a_position;

uniform mat3 projection;

void main() {
  vec2 position = (projection * vec3(a_position, 1)).xy;
  gl_Position = vec4(position, 0, 1);
}
`;

  var fillFragmentSrc = `precision mediump float;

uniform vec4 fillStyle;
uniform float globalAlpha;

void main() {
    gl_FragColor = fillStyle * globalAlpha;
}
`;

  var strokeVertexSrc = `precision highp float;
uniform float lineWidth, miterLimit;
uniform mat3 projection;
attribute vec2 position;
attribute vec3 pointA, pointB, pointC, pointD;

varying vec2 miterCoord1, miterCoord2;

mat3 miterTransform(vec2 xHat, vec2 yHat, vec2 v) {
  // Find a coordinate basis vector aligned along the bisector
  bool isCap = length(v) < 0.0001; // TODO: think about units
  vec2 vHat = (isCap)
    ? xHat // Treat v = 0 like 180 deg turn
    : normalize(v);
  vec2 m0 = (dot(xHat, vHat) < -0.9999)
    ? yHat // For vHat == -xHat
    : normalize(xHat + vHat);
  
  // Find a perpendicular basis vector, pointing toward xHat
  float x_m0 = dot(xHat, m0);
  vec2 m1 = (x_m0 < 0.9999)
    ? normalize(xHat - vHat)
    : yHat;

  // Compute miter length
  float sin2 = 1.0 - x_m0 * x_m0; // Could be zero!
  float miterLength = (sin2 > 0.0001)
    ? inversesqrt(sin2)
    : miterLimit + 1.0;
  float bevelLength = abs(dot(yHat, m0));
  float tx = (miterLength > miterLimit)
    ? 0.5 * lineWidth * bevelLength
    : 0.5 * lineWidth * miterLength;

  float ty = isCap ? 1.2 * lineWidth : 0.0;

  return mat3(m0.x, m1.x, 0, m0.y, m1.y, 0, tx, ty, 1);
}

void main() {
  vec2 xAxis = pointC.xy - pointB.xy;
  vec2 xBasis = normalize(xAxis);
  vec2 yBasis = vec2(-xBasis.y, xBasis.x);

  // Get coordinate transforms for the miters
  mat3 m1 = miterTransform(xBasis, yBasis, pointA.xy - pointB.xy);
  mat3 m2 = miterTransform(-xBasis, yBasis, pointD.xy - pointC.xy);

  // Find the position of the current instance vertex, in 3 coordinate systems
  vec2 extend = miterLimit * xBasis * lineWidth * (position.x - 0.5);
  vec2 point = pointB.xy + xAxis * position.x + yBasis * lineWidth * position.y + extend;
  miterCoord1 = (m1 * vec3(point - pointB.xy, 1)).xy;
  miterCoord2 = (m2 * vec3(point - pointC.xy, 1)).xy; 

  // Project the display position to clipspace coordinates
  vec2 projected = (projection * vec3(point, 1)).xy;
  gl_Position = vec4(projected, pointB.z + pointC.z, 1);
}
`;

  var strokeFragmentSrc = `precision highp float;
uniform vec4 strokeStyle;
uniform float globalAlpha;
varying vec2 miterCoord1, miterCoord2;

void main() {
  vec2 step1 = fwidth(miterCoord1);
  vec2 step2 = fwidth(miterCoord2);

  // Bevels, endcaps: Use smooth taper for antialiasing
  float taperx = 
    smoothstep(-0.5 * step1.x, 0.5 * step1.x, miterCoord1.x) *
    smoothstep(-0.5 * step2.x, 0.5 * step2.x, miterCoord2.x);

  // Miters: Use hard step, slightly shifted to avoid overlap at center
  float tapery = 
    step(-0.01 * step1.y, miterCoord1.y) *
    step(0.01 * step2.y, miterCoord2.y);

  vec4 premult = vec4(strokeStyle.rgb * strokeStyle.a, strokeStyle.a);
  gl_FragColor = premult * globalAlpha * taperx * tapery;
}
`;

  var textVertexSrc = `precision highp float;

attribute vec2 quadPos; // Vertices of the quad instance
attribute vec2 labelPos, charPos;
attribute vec4 sdfRect; // x, y, w, h

uniform mat3 projection;
uniform float fontScale;

varying vec2 texCoord;

void main() {
  vec2 dPos = sdfRect.zw * quadPos;
  texCoord = sdfRect.xy + dPos;
  vec2 vPos = labelPos + (charPos + dPos) * fontScale;

  vec2 projected = (projection * vec3(vPos, 1)).xy;
  gl_Position = vec4(projected, 0, 1);
}
`;

  var textFragmentSrc = `precision highp float;

uniform sampler2D sdf;
uniform vec2 sdfDim;
uniform vec4 fillStyle;
uniform float globalAlpha;

varying vec2 texCoord;

void main() {
  float sdfVal = texture2D(sdf, texCoord / sdfDim).a;
  // Find taper width: ~ dScreenPixels / dTexCoord
  float screenScale = 1.414 / length(fwidth(texCoord));
  float screenDist = screenScale * (191.0 - 255.0 * sdfVal) / 32.0;

  // TODO: threshold 0.5 looks too pixelated. Why?
  float alpha = smoothstep(-0.8, 0.8, -screenDist);
  gl_FragColor = fillStyle * (alpha * globalAlpha);
}
`;

  function initGLpaint(gl, framebuffer, framebufferSize) {
    // Input is an extended WebGL context, as created by yawgl.getExtendedContext
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    const fillProgram = initProgram(gl, fillVertexSrc, fillFragmentSrc);
    const strokeProgram = initProgram(gl, strokeVertexSrc, strokeFragmentSrc);
    const textProgram = initProgram(gl, textVertexSrc, textFragmentSrc);

    const transform = initTransform(framebufferSize);

    const uniforms = {
      projection: transform.matrix,
      fillStyle: [0, 0, 0, 1],
      strokeStyle: [0, 0, 0, 1],
      globalAlpha: 1.0,
      lineWidth: 1.0,
      miterLimit: 10.0,
      fontScale: 1.0,
      sdf: null,
      sdfDim: [256, 256],
    };

    function clear(color = [0.0, 0.0, 0.0, 0.0]) {
      gl.disable(gl.SCISSOR_TEST);
      gl.clearColor(...color);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }

    function clipRect(x, y, width, height) {
      gl.enable(gl.SCISSOR_TEST);
      let yflip = Math.round(framebufferSize.height - y - height);
      gl.scissor(Math.round(x), yflip, width, height);
    }

    function restore() {
      gl.disable(gl.SCISSOR_TEST);
      transform.set(1, 0, 0, 1, 0, 0);
    }

    function fill(buffers) {
      let { fillVao, indices: { vertexCount, type, offset } } = buffers;
      fillProgram.setupDraw({ uniforms, vao: fillVao });
      gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
      gl.bindVertexArray(null);
    }

    function stroke(buffers) {
      let { strokeVao, numInstances } = buffers;
      strokeProgram.setupDraw({ uniforms, vao: strokeVao });
      gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, numInstances);
      gl.bindVertexArray(null);
    }

    function fillText(buffers) {
      let { textVao, numInstances } = buffers;
      textProgram.setupDraw({ uniforms, vao: textVao });
      gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, numInstances);
      gl.bindVertexArray(null);
    }

    function fillRect(x, y, width, height) {
      clipRect(x, y, width, height);
      let opacity = uniforms.globalAlpha;
      let color = uniforms.fillStyle.map(c => c * opacity);
      clear(color);
    }

    function bindFramebufferAndSetViewport() {
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      let { width, height } = framebufferSize;
      gl.viewport(0, 0, width, height);
    }

    return {
      gl,
      canvas: framebufferSize,
      bindFramebufferAndSetViewport,

      // Mimic Canvas2D
      set globalAlpha(val) {
        uniforms.globalAlpha = val;
      },
      set fillStyle(val) {
        uniforms.fillStyle = convertColor(val);
      },
      set strokeStyle(val) {
        uniforms.strokeStyle = convertColor(val);
      },
      set lineWidth(val) {
        uniforms.lineWidth = val;
      },
      set miterLimit(val) {
        uniforms.miterLimit = val;
      },
      set font(val) {
        uniforms.sdf = val.sampler;
        uniforms.sdfDim = [val.width, val.height];
      },
      set fontSize(val) {
        uniforms.fontScale = val / 24.0; // TODO: get divisor from sdf-manager?
      },
      // TODO: implement dashed lines, patterns
      setLineDash: () => null,
      createPattern: () => null,

      save: () => null,
      getTransform: transform.get,
      setTransform: transform.set,
      transform: transform.transform,
      translate: transform.translate,
      scale: transform.scale,
      restore,

      constructFillVao: fillProgram.constructVao,
      constructStrokeVao: strokeProgram.constructVao,
      constructTextVao: textProgram.constructVao,

      clear,
      clearRect: () => clear(), // TODO: clipRect() before clear()?
      clipRect,
      fill,
      stroke,
      fillText,
      fillRect,
    };
  }

  function convertColor(cssString) {
    let c = rgb(cssString);
    return [c.r / 255, c.g / 255, c.b / 255, c.opacity];
  }

  const refProperties = [
    'type', 
    'source', 
    'source-layer', 
    'minzoom', 
    'maxzoom', 
    'filter', 
    'layout'
  ];

  function derefLayers(layers) {
    // From mapbox-gl-js, style-spec/deref.js
    /**
     * Given an array of layers, some of which may contain `ref` properties
     * whose value is the `id` of another property, return a new array where
     * such layers have been augmented with the 'type', 'source', etc. properties
     * from the parent layer, and the `ref` property has been removed.
     *
     * The input is not modified. The output may contain references to portions
     * of the input.
     */
    layers = layers.slice(); // ??? What are we trying to achieve here?

    const map = Object.create(null); // stackoverflow.com/a/21079232/10082269
    layers.forEach( layer => { map[layer.id] = layer; } );

    for (let i = 0; i < layers.length; i++) {
      if ('ref' in layers[i]) {
        layers[i] = deref(layers[i], map[layers[i].ref]);
      }
    }

    return layers;
  }

  function deref(layer, parent) {
    const result = {};

    for (const k in layer) {
      if (k !== 'ref') {
        result[k] = layer[k];
      }
    }

    refProperties.forEach((k) => {
      if (k in parent) {
        result[k] = parent[k];
      }
    });

    return result;
  }

  function expandStyleURL(url, token) {
    var prefix = /^mapbox:\/\/styles\//;
    if ( !url.match(prefix) ) return url;
    var apiRoot = "https://api.mapbox.com/styles/v1/";
    return url.replace(prefix, apiRoot) + "?access_token=" + token;
  }

  function expandSpriteURLs(url, token) {
    // Returns an array containing urls to .png and .json files
    var prefix = /^mapbox:\/\/sprites\//;
    if ( !url.match(prefix) ) return {
      image: url + ".png", 
      meta: url + ".json",
    };

    // We have a Mapbox custom url. Expand to an absolute URL, as per the spec
    var apiRoot = "https://api.mapbox.com/styles/v1/";
    url = url.replace(prefix, apiRoot) + "/sprite";
    var tokenString = "?access_token=" + token;
    return {
      image: url + ".png" + tokenString, 
      meta: url + ".json" + tokenString,
    };
  }

  function expandTileURL(url, token) {
    var prefix = /^mapbox:\/\//;
    if ( !url.match(prefix) ) return url;
    var apiRoot = "https://api.mapbox.com/v4/";
    return url.replace(prefix, apiRoot) + ".json?secure&access_token=" + token;
  }

  function expandGlyphURL(url, token) {
    var prefix = /^mapbox:\/\/fonts\//;
    if ( !url.match(prefix) ) return url;
    var apiRoot = "https://api.mapbox.com/fonts/v1/";
    return url.replace(prefix, apiRoot) + "?access_token=" + token;
  }

  function getJSON(dataHref) {
    // Wrap the fetch API to force a rejected promise if response is not OK
    const checkResponse = (response) => (response.ok)
      ? response.json()
      : Promise.reject(response); // Can check .status on returned response

    return fetch(dataHref).then(checkResponse);
  }

  function getImage(href) {
    const errMsg = "ERROR in getImage for href " + href;
    const img = new Image();

    return new Promise( (resolve, reject) => {
      img.onerror = () => reject(errMsg);

      img.onload = () => (img.complete && img.naturalWidth !== 0)
          ? resolve(img)
          : reject(errMsg);

      img.crossOrigin = "anonymous";
      img.src = href;
    });
  }

  function buildInterpFunc(base, sampleVal) {
    // Return a function to interpolate the value of y(x), given endpoints
    // p0 = (x0, y0) and p2 = (x1, y1)

    const scale = getScale(base);
    const interpolate = getInterpolator(sampleVal);

    return (p0, x, p1) => interpolate( p0[1], scale(p0[0], x, p1[0]), p1[1] );
  }

  function getScale(base) {
    // Return a function to find the relative position of x between a and b

    // Exponential scale follows mapbox-gl-js, style-spec/function/index.js
    // NOTE: https://github.com/mapbox/mapbox-gl-js/issues/2698 not addressed!
    const scale = (base === 1)
      ? (a, x, b) => (x - a) / (b - a)  // Linear scale
      : (a, x, b) => (Math.pow(base, x - a) - 1) / (Math.pow(base, b - a) - 1);

    // Add check for zero range
    return (a, x, b) => (a === b)
      ? 0
      : scale(a, x, b);
  }

  function getInterpolator(sampleVal) {
    // Return a function to find an interpolated value between end values v1, v2,
    // given relative position t between the two end positions

    var type = typeof sampleVal;
    if (type === "string" && color(sampleVal)) type = "color";

    switch (type) {
      case "number": // Linear interpolator
        return (v1, t, v2) => v1 + t * (v2 - v1);

      case "color":  // Interpolate RGBA
        return (v1, t, v2) => 
          interpColor( rgb(v1), t, rgb(v2) );

      default:       // Assume step function
        return (v1, t, v2) => v1;
    }
  }

  function interpColor(c0, t, c1) {
    // Inputs c0, c1 are rgb color objects as returned by d3.rgb
    const interpFloat = (a, b) => a + t * (b - a);
    const interpInteger = (a, b) => Math.round(interpFloat(a, b));

    return "rgba(" +
      interpInteger(c0.r, c1.r) + ", " +
      interpInteger(c0.g, c1.g) + ", " + 
      interpInteger(c0.b, c1.b) + ", " +
      interpFloat(c0.a, c1.a) + ")";
  }

  function autoGetters(properties = {}, defaults) {
    const getters = {};
    Object.keys(defaults).forEach(key => {
      getters[key] = buildStyleFunc(properties[key], defaults[key]);
    });
    return getters;
  }

  function buildStyleFunc(style, defaultVal) {
    var styleFunc, getArg;

    if (style === undefined) {
      styleFunc = () => defaultVal;
      styleFunc.type = "constant";

    } else if (typeof style !== "object" || Array.isArray(style)) {
      styleFunc = () => style;
      styleFunc.type = "constant";

    } else if (!style.property || style.property === "zoom") {
      getArg = (zoom, feature) => zoom;
      styleFunc = getStyleFunc(style, getArg);
      styleFunc.type = "zoom";

    } else {
      let propertyName = style.property;
      getArg = (zoom, feature) => feature.properties[propertyName];
      styleFunc = getStyleFunc(style, getArg);
      styleFunc.type = "property";
      styleFunc.property = propertyName;

    } // NOT IMPLEMENTED: zoom-and-property functions

    return styleFunc;
  }

  function getStyleFunc(style, getArg) {
    if (style.type === "identity") return getArg;

    // We should be building a stop function now. Make sure we have enough info
    var stops = style.stops;
    if (!stops || stops.length < 2 || stops[0].length !== 2) {
      console.log("buildStyleFunc: style = " + JSON.stringify(style));
      console.log("ERROR in buildStyleFunc: failed to understand style!");
      return;
    }

    var stopFunc = buildStopFunc(stops, style.base);
    return (zoom, feature) => stopFunc( getArg(zoom, feature) );
  }

  function buildStopFunc(stops, base = 1) {
    const izm = stops.length - 1;
    const interpolateVal = buildInterpFunc(base, stops[0][1]);

    return function(x) {
      let iz = stops.findIndex(stop => stop[0] > x);

      if (iz === 0) return stops[0][1]; // x is below first stop
      if (iz < 0) return stops[izm][1]; // x is above last stop

      return interpolateVal(stops[iz-1], x, stops[iz]);
    }
  }

  const layoutDefaults = {
    "background": {
      "visibility": "visible",
    },
    "fill": {
      "visibility": "visible",
    },
    "line": {
      "visibility": "visible",
      "line-cap": "butt",
      "line-join": "miter",
      "line-miter-limit": 2,
      "line-round-limit": 1.05,
    },
    "symbol": {
      "visibility": "visible",

      "symbol-placement": "point",
      "symbol-spacing": 250,
      "symbol-avoid-edges": false,
      "symbol-sort-key": undefined,
      "symbol-z-order": "auto",

      "icon-allow-overlap": false,
      "icon-ignore-placement": false,
      "icon-optional": false,
      "icon-rotation-alignment": "auto",
      "icon-size": 1,
      "icon-text-fit": "none",
      "icon-text-fit-padding": [0, 0, 0, 0],
      "icon-image": undefined,
      "icon-rotate": 0,
      "icon-padding": 2,
      "icon-keep-upright": false,
      "icon-offset": [0, 0],
      "icon-anchor": "center",
      "icon-pitch-alignment": "auto",

      "text-pitch-alignment": "auto",
      "text-rotation-alignment": "auto",
      "text-field": "",
      "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
      "text-size": 16,
      "text-max-width": 10,
      "text-line-height": 1.2,
      "text-letter-spacing": 0,
      "text-justify": "center",
      "text-radial-offset": 0,
      "text-variable-anchor": undefined,
      "text-anchor": "center",
      "text-max-angle": 45,
      "text-rotate": 0,
      "text-padding": 2.0,
      "text-keep-upright": true,
      "text-transform": "none",
      "text-offset": [0, 0],
      "text-allow-overlap": false,
      "text-ignore-placement": false,
      "text-optional": false,
    },
    "raster": {
      "visibility": "visible",
    },
    "circle": {
      "visibility": "visible",
    },
    "fill-extrusion": {
      "visibility": "visible",
    },
    "heatmap": {
      "visibility": "visible",
    },
    "hillshade": {
      "visibility": "visible",
    },
  };

  const paintDefaults = {
    "background": {
      "background-color": "#000000",
      "background-opacity": 1,
      "background-pattern": undefined,
    },
    "fill": {
      "fill-antialias": true,
      "fill-opacity": 1,
      "fill-color": "#000000",
      "fill-outline-color": undefined,
      "fill-outline-width": 1, // non-standard!
      "fill-translate": [0, 0],
      "fill-translate-anchor": "map",
      "fill-pattern": undefined,
    },
    "line": {
      "line-opacity": 1,
      "line-color": "#000000",
      "line-translate": [0, 0],
      "line-translate-anchor": "map",
      "line-width": 1,
      "line-gap-width": 0,
      "line-offset": 0,
      "line-blur": 0,
      "line-dasharray": undefined,
      "line-pattern": undefined,
      "line-gradient": undefined,
    },
    "symbol": {
      "icon-opacity": 1,
      "icon-color": "#000000",
      "icon-halo-color": "rgba(0, 0, 0, 0)",
      "icon-halo-width": 0,
      "icon-halo-blur": 0,
      "icon-translate": [0, 0],
      "icon-translate-anchor": "map",

      "text-opacity": 1,
      "text-color": "#000000",
      "text-halo-color": "rgba(0, 0, 0, 0)",
      "text-halo-width": 0,
      "text-halo-blur": 0,
      "text-translate": [0, 0],
      "text-translate-anchor": "map",
    },
    "raster": {
      "raster-opacity": 1,
      "raster-hue-rotate": 0,
      "raster-brighness-min": 0,
      "raster-brightness-max": 1,
      "raster-saturation": 0,
      "raster-contrast": 0,
      "raster-resampling": "linear",
      "raster-fade-duration": 300,
    },
    "circle": {
      "circle-radius": 5,
      "circle-color": "#000000",
      "circle-blur": 0,
      "circle-opacity": 1,
      "circle-translate": [0, 0],
      "circle-translate-anchor": "map",
      "circle-pitch-scale": "map",
      "circle-pitch-alignment": "viewport",
      "circle-stroke-width": 0,
      "circle-stroke-color": "#000000",
      "circle-stroke-opacity": 1,
    },
    "fill-extrusion": {
      "fill-extrusion-opacity": 1,
      "fill-extrusion-color": "#000000",
      "fill-extrusion-translate": [0, 0],
      "fill-extrusion-translate-anchor": "map",
      "fill-extrusion-height": 0,
      "fill-extrusion-base": 0,
      "fill-extrusion-vertical-gradient": true,
    },
    "heatmap": {
      "heatmap-radius": 30,
      "heatmap-weight": 1,
      "heatmap-intensity": 1,
      "heatmap-color": ["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],
      "heatmap-opacity": 1,
    },
    "hillshade": {
      "hillshade-illumination-direction": 335,
      "hillshade-illumination-anchor": "viewport",
      "hillshade-exaggeration": 0.5,
      "hillshade-shadow-color": "#000000",
      "hillshade-highlight-color": "#FFFFFF",
      "hillshade-accent-color": "#000000",
    },
  };

  function getStyleFuncs(inputLayer) {
    const layer = Object.assign({}, inputLayer); // Leave input unchanged

    // Replace rendering properties with functions
    layer.layout = autoGetters(layer.layout, layoutDefaults[layer.type]);
    layer.paint  = autoGetters(layer.paint,  paintDefaults[layer.type] );

    return layer;
  }

  function loadStyle(style, mapboxToken) {
    // Loads a style document and any linked information

    const getStyle = (typeof style === "object")
      ? Promise.resolve(style)                // style is JSON already
      : getJSON( expandStyleURL(style, mapboxToken) ); // Get from URL

    return getStyle
      .then( styleDoc => expandLinks(styleDoc, mapboxToken) );
  }

  function expandLinks(styleDoc, mapboxToken) {
    styleDoc.layers = derefLayers(styleDoc.layers);
    if (styleDoc.glyphs) {
      styleDoc.glyphs = expandGlyphURL(styleDoc.glyphs, mapboxToken);
    }

    return Promise.all([
      expandSources(styleDoc.sources, mapboxToken),
      loadSprite(styleDoc.sprite, mapboxToken),
    ]).then( ([sources, spriteData]) => {
      styleDoc.sources = sources;
      styleDoc.spriteData = spriteData;
      return styleDoc;
    });
  }

  function expandSources(rawSources, token) {
    const expandPromises = Object.entries(rawSources).map(expandSource);

    function expandSource([key, source]) {
      // If no .url, return a shallow copy of the input. 
      // Note: some properties may still be pointing back to the original 
      // style document, like .vector_layers, .bounds, .center, .extent
      if (source.url === undefined) return [key, Object.assign({}, source)];

      // Load the referenced TileJSON document, add any values from source
      return getJSON( expandTileURL(source.url, token) )
        .then( tileJson => [key, Object.assign(tileJson, source)] );
    }

    function combineSources(keySourcePairs) {
      const sources = {};
      keySourcePairs.forEach( ([key, val]) => { sources[key] = val; } );
      return sources;
    }

    return Promise.all( expandPromises ).then( combineSources );
  }

  function loadSprite(sprite, token) {
    if (!sprite) return;

    const urls = expandSpriteURLs(sprite, token);

    return Promise.all([getImage(urls.image), getJSON(urls.meta)])
      .then( ([image, meta]) => ({ image, meta }) );
  }

  initZeroTimeouts();

  function initZeroTimeouts() {
    // setTimeout with true zero delay. https://github.com/GlobeletJS/zero-timeout
    const timeouts = [];
    var taskId = 0;

    // Make a unique message, that won't be confused with messages from
    // other scripts or browser tabs
    const messageKey = "zeroTimeout_$" + Math.random().toString(36).slice(2);

    // Make it clear where the messages should be coming from
    const loc = window.location;
    var targetOrigin = loc.protocol + "//" + loc.hostname;
    if (loc.port !== "") targetOrigin += ":" + loc.port;

    // When a message is received, execute a timeout from the list
    window.addEventListener("message", evnt => {
      if (evnt.source != window || evnt.data !== messageKey) return;
      evnt.stopPropagation();

      let task = timeouts.shift();
      if (!task || task.canceled) return;
      task.func(...task.args);
    }, true);

    // Now define the external functions to set or cancel a timeout
    window.setZeroTimeout = function(func, ...args) {
      taskId += 1;
      timeouts.push({ id: taskId, func, args });
      window.postMessage(messageKey, targetOrigin);
      return taskId;
    };

    window.clearZeroTimeout = function(id) {
      let task = timeouts.find(timeout => timeout.id === id);
      if (task) task.canceled = true;
    };
  }

  function init() {
    const tasks = [];
    var taskId = 0;
    var queueIsRunning = false;

    return {
      enqueueTask,
      cancelTask,
      sortTasks,
      countTasks: () => tasks.length,
    };

    function enqueueTask(newTask) {
      const defaultPriority = () => 0;
      taskId += 1;
      tasks.push({ 
        id: taskId,
        getPriority: newTask.getPriority || defaultPriority,
        chunks: newTask.chunks,
      });
      if (!queueIsRunning) setZeroTimeout(runTaskQueue);
      return taskId;
    }

    function cancelTask(id) {
      let task = tasks.find(task => task.id === id);
      if (task) task.canceled = true;
    }

    function sortTasks() {
      tasks.sort( (a, b) => compareNums(a.getPriority(), b.getPriority()) );
    }

    function compareNums(a, b) {
      if (a === b) return 0;
      return (a === undefined || a < b) ? -1 : 1;
    }

    function runTaskQueue() {
      // Remove canceled and completed tasks
      while (isDone(tasks[0])) tasks.shift();

      queueIsRunning = (tasks.length > 0);
      if (!queueIsRunning) return;

      // Get the next chunk from the current task, and run it
      let chunk = tasks[0].chunks.shift();
      chunk();

      setZeroTimeout(runTaskQueue);
    }

    function isDone(task) {
      return task && (task.canceled || task.chunks.length < 1);
    }
  }

  function initRasterLoader(source) {
    const getURL = initUrlFunc(source.tiles);

    function request({ z, x, y, callback }) {
      const href = getURL(z, x, y);
      const errMsg = "ERROR in loadImage for href " + href;

      const img = new Image();
      img.onerror = () => callback(errMsg);
      img.onload = () => {
        return img.complete && img.naturalWidth !== 0
          ? callback(null, img)
          : callback(errMsg);
      };
      img.crossOrigin = "anonymous";
      img.src = href;

      function abort() {
        img.src = "";
      }

      return { abort };
    }

    return { request };
  }

  function initUrlFunc(endpoints) {
    if (!endpoints || !endpoints.length) {
      throw Error("ERROR in initUrlFunc: no valid tile endpoints!");
    }

    // Use a different endpoint for each request
    var index = 0;

    return function(z, x, y) {
      index = (index + 1) % endpoints.length;
      var endpoint = endpoints[index];
      return endpoint
        .replace(/{z}/, z)
        .replace(/{x}/, x)
        .replace(/{y}/, y);
    };
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;
  const clipLat = (lat) => Math.min(Math.max(-maxMercLat, lat), maxMercLat);

  function lonLatToXY(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX( geodetic[0] );
    projected[1] = latToY( geodetic[1] );
    return projected;
  }

  function lonToX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = maxMercLat, y = 1 at lat = -maxMercLat
    var y = 0.5 - 0.5 / Math.PI *
      Math.log( Math.tan(Math.PI / 4.0 + clipLat(lat) / 2.0) );

    return Math.min(Math.max(0.0, y), 1.0); // Y does not wrap around
  }

  function buildFactory({ source, loader, reporter }) {
    const {
      minzoom = 0,
      maxzoom = 30,
      bounds = [-180, -90, 180, 90],
      scheme = "xyz",
    } = source;

    // Convert bounds to Web Mercator (the projection ASSUMED by tilejson-spec)
    let [xmin, ymax] = lonLatToXY([], bounds.slice(0, 2));
    let [xmax, ymin] = lonLatToXY([], bounds.slice(2, 4));
    if (scheme === "tms") [ymin, ymax] = [ymax, ymin];

    return function(z, x, y) {
      // Exit if out of bounds
      if (z < minzoom || maxzoom < z) return;
      let zFac = 1 / 2 ** z;
      if ((x + 1) * zFac < xmin || xmax < x * zFac) return;
      if ((y + 1) * zFac < ymin || ymax < y * zFac) return;

      let id = [z, x, y].join("/");
      const tile = { z, x, y, id, priority: 0 };

      function callback(err, data) {
        if (err) return; // console.log(err);
        tile.data = data;
        tile.ready = true;
        reporter.dispatchEvent(new Event("tileLoaded"));
      }

      const getPriority = () => tile.priority;
      const loadTask = loader.request({ z, x, y, getPriority, callback });

      tile.cancel = () => {
        loadTask.abort();
        tile.canceled = true;
      };

      return tile;
    }
  }

  initZeroTimeouts$1();

  function initZeroTimeouts$1() {
    // setTimeout with true zero delay. https://github.com/GlobeletJS/zero-timeout
    const timeouts = [];
    var taskId = 0;

    // Make a unique message, that won't be confused with messages from
    // other scripts or browser tabs
    const messageKey = "zeroTimeout_$" + Math.random().toString(36).slice(2);

    // Make it clear where the messages should be coming from
    const loc = window.location;
    var targetOrigin = loc.protocol + "//" + loc.hostname;
    if (loc.port !== "") targetOrigin += ":" + loc.port;

    // When a message is received, execute a timeout from the list
    window.addEventListener("message", evnt => {
      if (evnt.source != window || evnt.data !== messageKey) return;
      evnt.stopPropagation();

      let task = timeouts.shift();
      if (!task || task.canceled) return;
      task.func(...task.args);
    }, true);

    // Now define the external functions to set or cancel a timeout
    window.setZeroTimeout = function(func, ...args) {
      taskId += 1;
      timeouts.push({ id: taskId, func, args });
      window.postMessage(messageKey, targetOrigin);
      return taskId;
    };

    window.clearZeroTimeout = function(id) {
      let task = timeouts.find(timeout => timeout.id === id);
      if (task) task.canceled = true;
    };
  }

  function init$1() {
    const tasks = [];
    var taskId = 0;
    var queueIsRunning = false;

    return {
      enqueueTask,
      cancelTask,
      sortTasks,
      countTasks: () => tasks.length,
    };

    function enqueueTask(newTask) {
      const defaultPriority = () => 0;
      taskId += 1;
      tasks.push({ 
        id: taskId,
        getPriority: newTask.getPriority || defaultPriority,
        chunks: newTask.chunks,
      });
      if (!queueIsRunning) setZeroTimeout(runTaskQueue);
      return taskId;
    }

    function cancelTask(id) {
      let task = tasks.find(task => task.id === id);
      if (task) task.canceled = true;
    }

    function sortTasks() {
      tasks.sort( (a, b) => compareNums(a.getPriority(), b.getPriority()) );
    }

    function compareNums(a, b) {
      if (a === b) return 0;
      return (a === undefined || a < b) ? -1 : 1;
    }

    function runTaskQueue() {
      // Remove canceled and completed tasks
      while (isDone(tasks[0])) tasks.shift();

      queueIsRunning = (tasks.length > 0);
      if (!queueIsRunning) return;

      // Get the next chunk from the current task, and run it
      let chunk = tasks[0].chunks.shift();
      chunk();

      setZeroTimeout(runTaskQueue);
    }

    function isDone(task) {
      return task && (task.canceled || task.chunks.length < 1);
    }
  }

  const vectorTypes = ["symbol", "circle", "line", "fill"];

  function setParams(userParams) {
    const {
      threads = 2,
      context,
      glyphs,
      source,
      layers,
      verbose = false,
      queue = init$1(),
    } = userParams;

    // Confirm supplied styles are all vector layers reading from the same source
    if (!layers || !layers.length) fail$1("no valid array of style layers!");

    let allVectors = layers.every( l => vectorTypes.includes(l.type) );
    if (!allVectors) fail$1("not all layers are vector types!");

    let sameSource = layers.every( l => l.source === layers[0].source );
    if (!sameSource) fail$1("supplied layers use different sources!");

    // Construct function to get a tile URL
    if (!source) fail$1("parameters.source is required!");
    const getURL = initUrlFunc$1(source.tiles);

    return {
      context,
      threads,
      glyphs,
      getURL,
      layers,
      queue,
      verbose,
    };
  }

  function initUrlFunc$1(endpoints) {
    if (!endpoints || !endpoints.length) fail$1("no valid tile endpoints!");

    // Use a different endpoint for each request
    var index = 0;

    return function(z, x, y) {
      index = (index + 1) % endpoints.length;
      var endpoint = endpoints[index];
      return endpoint.replace(/{z}/, z).replace(/{x}/, x).replace(/{y}/, y);
    };
  }

  function fail$1(message) {
    throw Error("ERROR in tile-mixer: " + message);
  }

  function initWorkers(codeHref, params) {
    const { threads, glyphs, layers } = params;

    const tasks = {};
    var msgId = 0;

    // Initialize the worker threads, and send them the styles
    function trainWorker() {
      const worker = new Worker(codeHref);
      const payload = { styles: layers, glyphEndpoint: glyphs };
      worker.postMessage({ id: 0, type: "styles", payload });
      worker.onmessage = handleMsg;
      return worker;
    }
    const workers = Array.from(Array(threads), trainWorker);
    const workLoads = Array.from(Array(threads), () => 0);

    return {
      startTask,
      cancelTask,
      activeTasks: () => workLoads.reduce( (a, b) => a + b, 0 ),
      terminate: () => workers.forEach( worker => worker.terminate() ),
    }

    function startTask(payload, callback) {
      let workerID = getIdleWorkerID(workLoads);
      workLoads[workerID] += 1;

      msgId += 1;
      tasks[msgId] = { callback, workerID };
      workers[workerID].postMessage({ id: msgId, type: "start", payload });

      return msgId; // Returned ID can be used for later cancellation
    }

    function cancelTask(id) {
      let task = tasks[id];
      if (!task) return;
      workers[task.workerID].postMessage({ id, type: "cancel" });
      workLoads[task.workerID] -= 1;
      delete tasks[id];
    }

    function handleMsg(msgEvent) {
      const msg = msgEvent.data; // { id, type, payload }
      const task = tasks[msg.id];
      // NOTE: 'this' is the worker that emitted msgEvent
      if (!task) return this.postMessage({ id: msg.id, type: "cancel" });

      switch (msg.type) {
        case "error":
          task.callback(msg.payload);
          break;

        case "data":
          task.callback(null, msg.payload);
          break;

        default:
          task.callback("ERROR: worker sent bad message type!");
          break;
      }

      workLoads[task.workerID] -= 1;
      delete tasks[msg.id];
    }
  }

  function getIdleWorkerID(workLoads) {
    let id = 0;
    for (let i = 1; i < workLoads.length; i++) {
      if (workLoads[i] < workLoads[id]) id = i;
    }
    return id;
  }

  function initFillBufferLoader(context, lineLoader) {
    const { gl, constructFillVao } = context;

    return function(buffers) {
      const vertexPositions = {
        buffer: gl.createBuffer(),
        numComponents: 2,
        type: gl.FLOAT,
        normalize: false,
        stride: 0,
        offset: 0
      };
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositions.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, buffers.vertices, gl.STATIC_DRAW);

      const indices = {
        buffer: gl.createBuffer(),
        vertexCount: buffers.indices.length,
        type: gl.UNSIGNED_SHORT,
        offset: 0
      };
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices.buffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffers.indices, gl.STATIC_DRAW);

      const attributes = { a_position: vertexPositions };
      const fillVao = constructFillVao({ attributes, indices });
      const path = { fillVao, indices };

      const strokePath = lineLoader(buffers);

      return Object.assign(path, strokePath);
    }
  }

  function initLineBufferLoader(context) {
    const { gl, constructStrokeVao } = context;

    // Create a buffer with the position of the vertices within one instance
    const instanceGeom = new Float32Array([
      0, -0.5,   1, -0.5,   1,  0.5,
      0, -0.5,   1,  0.5,   0,  0.5
    ]);

    const position = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0,
      divisor: 0,
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, position.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, instanceGeom, gl.STATIC_DRAW);

    return function(buffers) {
      const numComponents = 3;
      const numInstances = buffers.points.length / numComponents - 3;

      // Create buffer containing the vertex positions
      const pointsBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, buffers.points, gl.STATIC_DRAW);

      // Create interleaved attributes pointing to different offsets in buffer
      const attributes = {
        position,
        pointA: setupPoint(0),
        pointB: setupPoint(1),
        pointC: setupPoint(2),
        pointD: setupPoint(3),
      };

      function setupPoint(offset) {
        return {
          buffer: pointsBuffer,
          numComponents: numComponents,
          type: gl.FLOAT,
          normalize: false,
          stride: Float32Array.BYTES_PER_ELEMENT * numComponents,
          offset: Float32Array.BYTES_PER_ELEMENT * numComponents * offset,
          divisor: 1
        };
      }

      const strokeVao = constructStrokeVao({ attributes });

      return { strokeVao, numInstances };
    };
  }

  function initTextBufferLoader(context) {
    const { gl, constructTextVao } = context;

    // Create a buffer with the position of the vertices within one instance
    const instanceGeom = new Float32Array([
      0.0,  0.0,   1.0,  0.0,   1.0,  1.0,
      0.0,  0.0,   1.0,  1.0,   0.0,  1.0
    ]);

    const quadPos = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0,
      divisor: 0,
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, quadPos.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, instanceGeom, gl.STATIC_DRAW);

    return function(buffers) {
      const { origins, deltas, rects } = buffers;
      const numInstances = origins.length / 2;

      const labelPos = {
        buffer: gl.createBuffer(),
        numComponents: 2,
        type: gl.FLOAT,
        normalize: false,
        stride: 0,
        offset: 0,
        divisor: 1,
      };
      gl.bindBuffer(gl.ARRAY_BUFFER, labelPos.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, origins, gl.STATIC_DRAW);

      const charPos = {
        buffer: gl.createBuffer(),
        numComponents: 2,
        type: gl.FLOAT,
        normalize: false,
        stride: 0,
        offset: 0,
        divisor: 1,
      };
      gl.bindBuffer(gl.ARRAY_BUFFER, charPos.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, deltas, gl.STATIC_DRAW);

      const sdfRect = {
        buffer: gl.createBuffer(),
        numComponents: 4,
        type: gl.FLOAT,
        normalize: false,
        stride: 0,
        offset: 0,
        divisor: 1,
      };
      gl.bindBuffer(gl.ARRAY_BUFFER, sdfRect.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, rects, gl.STATIC_DRAW);

      const attributes = { quadPos, labelPos, charPos, sdfRect };
      const textVao = constructTextVao({ attributes });

      return { textVao, numInstances };
    };
  }

  function initAtlasLoader(context) {
    const { gl } = context;

    return function(atlas) {
      const { width, height, data } = atlas;

      const target = gl.TEXTURE_2D;
      const texture = gl.createTexture();
      gl.bindTexture(target, texture);

      const level = 0;
      const format = gl.ALPHA;
      const border = 0;
      const type = gl.UNSIGNED_BYTE;

      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

      gl.texImage2D(target, level, format, 
        width, height, border, format, type, data);

      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

      return { width, height, sampler: texture };
    };
  }

  function initDataPrep(styles, context) {
    const lineLoader = initLineBufferLoader(context);
    const fillLoader = initFillBufferLoader(context, lineLoader);
    const textLoader = initTextBufferLoader(context);
    const loadAtlas  = initAtlasLoader(context);

    const pathFuncs = {
      "circle": () => undefined, // TODO
      "line": makePathAdder(lineLoader),
      "fill": makePathAdder(fillLoader),
      "symbol": makePathAdder(textLoader), // TODO: add sprite handling
    };

    // Build a dictionary of data prep functions, keyed on style.id
    const prepFunctions = styles.reduce((dict, style) => {
      let { id, type } = style;
      dict[id] = pathFuncs[type];
      return dict;
    }, {});

    // Return a function that creates an array of prep calls for a source
    return function (source, zoom) {
      let { atlas, layers } = source;

      const prepTasks = Object.keys(layers)
        .map(id => () => prepFunctions[id](layers[id], zoom));

      prepTasks.push(() => { source.atlas = loadAtlas(atlas); });

      return prepTasks;
    };
  }

  function makePathAdder(pathFunc) {
    // TODO: make this more functional? Note: keeping feature.properties
    return (features) => features.forEach(feature => {
      feature.path = pathFunc(feature.buffers);
      delete feature.buffers;  // Should we do this?
    });
  }

  var workerCode = String.raw`function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

function buildInterpFunc(base, sampleVal) {
  // Return a function to interpolate the value of y(x), given endpoints
  // p0 = (x0, y0) and p2 = (x1, y1)

  const scale = getScale(base);
  const interpolate = getInterpolator(sampleVal);

  return (p0, x, p1) => interpolate( p0[1], scale(p0[0], x, p1[0]), p1[1] );
}

function getScale(base) {
  // Return a function to find the relative position of x between a and b

  // Exponential scale follows mapbox-gl-js, style-spec/function/index.js
  // NOTE: https://github.com/mapbox/mapbox-gl-js/issues/2698 not addressed!
  const scale = (base === 1)
    ? (a, x, b) => (x - a) / (b - a)  // Linear scale
    : (a, x, b) => (Math.pow(base, x - a) - 1) / (Math.pow(base, b - a) - 1);

  // Add check for zero range
  return (a, x, b) => (a === b)
    ? 0
    : scale(a, x, b);
}

function getInterpolator(sampleVal) {
  // Return a function to find an interpolated value between end values v1, v2,
  // given relative position t between the two end positions

  var type = typeof sampleVal;
  if (type === "string" && color(sampleVal)) type = "color";

  switch (type) {
    case "number": // Linear interpolator
      return (v1, t, v2) => v1 + t * (v2 - v1);

    case "color":  // Interpolate RGBA
      return (v1, t, v2) => 
        interpColor( rgb(v1), t, rgb(v2) );

    default:       // Assume step function
      return (v1, t, v2) => v1;
  }
}

function interpColor(c0, t, c1) {
  // Inputs c0, c1 are rgb color objects as returned by d3.rgb
  const interpFloat = (a, b) => a + t * (b - a);
  const interpInteger = (a, b) => Math.round(interpFloat(a, b));

  return "rgba(" +
    interpInteger(c0.r, c1.r) + ", " +
    interpInteger(c0.g, c1.g) + ", " + 
    interpInteger(c0.b, c1.b) + ", " +
    interpFloat(c0.a, c1.a) + ")";
}

function autoGetters(properties = {}, defaults) {
  const getters = {};
  Object.keys(defaults).forEach(key => {
    getters[key] = buildStyleFunc(properties[key], defaults[key]);
  });
  return getters;
}

function buildStyleFunc(style, defaultVal) {
  var styleFunc, getArg;

  if (style === undefined) {
    styleFunc = () => defaultVal;
    styleFunc.type = "constant";

  } else if (typeof style !== "object" || Array.isArray(style)) {
    styleFunc = () => style;
    styleFunc.type = "constant";

  } else if (!style.property || style.property === "zoom") {
    getArg = (zoom, feature) => zoom;
    styleFunc = getStyleFunc(style, getArg);
    styleFunc.type = "zoom";

  } else {
    let propertyName = style.property;
    getArg = (zoom, feature) => feature.properties[propertyName];
    styleFunc = getStyleFunc(style, getArg);
    styleFunc.type = "property";
    styleFunc.property = propertyName;

  } // NOT IMPLEMENTED: zoom-and-property functions

  return styleFunc;
}

function getStyleFunc(style, getArg) {
  if (style.type === "identity") return getArg;

  // We should be building a stop function now. Make sure we have enough info
  var stops = style.stops;
  if (!stops || stops.length < 2 || stops[0].length !== 2) {
    console.log("buildStyleFunc: style = " + JSON.stringify(style));
    console.log("ERROR in buildStyleFunc: failed to understand style!");
    return;
  }

  var stopFunc = buildStopFunc(stops, style.base);
  return (zoom, feature) => stopFunc( getArg(zoom, feature) );
}

function buildStopFunc(stops, base = 1) {
  const izm = stops.length - 1;
  const interpolateVal = buildInterpFunc(base, stops[0][1]);

  return function(x) {
    let iz = stops.findIndex(stop => stop[0] > x);

    if (iz === 0) return stops[0][1]; // x is below first stop
    if (iz < 0) return stops[izm][1]; // x is above last stop

    return interpolateVal(stops[iz-1], x, stops[iz]);
  }
}

const layoutDefaults = {
  "background": {
    "visibility": "visible",
  },
  "fill": {
    "visibility": "visible",
  },
  "line": {
    "visibility": "visible",
    "line-cap": "butt",
    "line-join": "miter",
    "line-miter-limit": 2,
    "line-round-limit": 1.05,
  },
  "symbol": {
    "visibility": "visible",

    "symbol-placement": "point",
    "symbol-spacing": 250,
    "symbol-avoid-edges": false,
    "symbol-sort-key": undefined,
    "symbol-z-order": "auto",

    "icon-allow-overlap": false,
    "icon-ignore-placement": false,
    "icon-optional": false,
    "icon-rotation-alignment": "auto",
    "icon-size": 1,
    "icon-text-fit": "none",
    "icon-text-fit-padding": [0, 0, 0, 0],
    "icon-image": undefined,
    "icon-rotate": 0,
    "icon-padding": 2,
    "icon-keep-upright": false,
    "icon-offset": [0, 0],
    "icon-anchor": "center",
    "icon-pitch-alignment": "auto",

    "text-pitch-alignment": "auto",
    "text-rotation-alignment": "auto",
    "text-field": "",
    "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
    "text-size": 16,
    "text-max-width": 10,
    "text-line-height": 1.2,
    "text-letter-spacing": 0,
    "text-justify": "center",
    "text-radial-offset": 0,
    "text-variable-anchor": undefined,
    "text-anchor": "center",
    "text-max-angle": 45,
    "text-rotate": 0,
    "text-padding": 2.0,
    "text-keep-upright": true,
    "text-transform": "none",
    "text-offset": [0, 0],
    "text-allow-overlap": false,
    "text-ignore-placement": false,
    "text-optional": false,
  },
  "raster": {
    "visibility": "visible",
  },
  "circle": {
    "visibility": "visible",
  },
  "fill-extrusion": {
    "visibility": "visible",
  },
  "heatmap": {
    "visibility": "visible",
  },
  "hillshade": {
    "visibility": "visible",
  },
};

const paintDefaults = {
  "background": {
    "background-color": "#000000",
    "background-opacity": 1,
    "background-pattern": undefined,
  },
  "fill": {
    "fill-antialias": true,
    "fill-opacity": 1,
    "fill-color": "#000000",
    "fill-outline-color": undefined,
    "fill-outline-width": 1, // non-standard!
    "fill-translate": [0, 0],
    "fill-translate-anchor": "map",
    "fill-pattern": undefined,
  },
  "line": {
    "line-opacity": 1,
    "line-color": "#000000",
    "line-translate": [0, 0],
    "line-translate-anchor": "map",
    "line-width": 1,
    "line-gap-width": 0,
    "line-offset": 0,
    "line-blur": 0,
    "line-dasharray": undefined,
    "line-pattern": undefined,
    "line-gradient": undefined,
  },
  "symbol": {
    "icon-opacity": 1,
    "icon-color": "#000000",
    "icon-halo-color": "rgba(0, 0, 0, 0)",
    "icon-halo-width": 0,
    "icon-halo-blur": 0,
    "icon-translate": [0, 0],
    "icon-translate-anchor": "map",

    "text-opacity": 1,
    "text-color": "#000000",
    "text-halo-color": "rgba(0, 0, 0, 0)",
    "text-halo-width": 0,
    "text-halo-blur": 0,
    "text-translate": [0, 0],
    "text-translate-anchor": "map",
  },
  "raster": {
    "raster-opacity": 1,
    "raster-hue-rotate": 0,
    "raster-brighness-min": 0,
    "raster-brightness-max": 1,
    "raster-saturation": 0,
    "raster-contrast": 0,
    "raster-resampling": "linear",
    "raster-fade-duration": 300,
  },
  "circle": {
    "circle-radius": 5,
    "circle-color": "#000000",
    "circle-blur": 0,
    "circle-opacity": 1,
    "circle-translate": [0, 0],
    "circle-translate-anchor": "map",
    "circle-pitch-scale": "map",
    "circle-pitch-alignment": "viewport",
    "circle-stroke-width": 0,
    "circle-stroke-color": "#000000",
    "circle-stroke-opacity": 1,
  },
  "fill-extrusion": {
    "fill-extrusion-opacity": 1,
    "fill-extrusion-color": "#000000",
    "fill-extrusion-translate": [0, 0],
    "fill-extrusion-translate-anchor": "map",
    "fill-extrusion-height": 0,
    "fill-extrusion-base": 0,
    "fill-extrusion-vertical-gradient": true,
  },
  "heatmap": {
    "heatmap-radius": 30,
    "heatmap-weight": 1,
    "heatmap-intensity": 1,
    "heatmap-color": ["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],
    "heatmap-opacity": 1,
  },
  "hillshade": {
    "hillshade-illumination-direction": 335,
    "hillshade-illumination-anchor": "viewport",
    "hillshade-exaggeration": 0.5,
    "hillshade-shadow-color": "#000000",
    "hillshade-highlight-color": "#FFFFFF",
    "hillshade-accent-color": "#000000",
  },
};

function getStyleFuncs(inputLayer) {
  const layer = Object.assign({}, inputLayer); // Leave input unchanged

  // Replace rendering properties with functions
  layer.layout = autoGetters(layer.layout, layoutDefaults[layer.type]);
  layer.paint  = autoGetters(layer.paint,  paintDefaults[layer.type] );

  return layer;
}

function buildFeatureFilter(filterObj) {
  // filterObj is a filter definition following the "deprecated" syntax:
  // https://docs.mapbox.com/mapbox-gl-js/style-spec/#other-filter
  if (!filterObj) return () => true;
  const [type, ...vals] = filterObj;

  // If this is a combined filter, the vals are themselves filter definitions
  switch (type) {
    case "all": {
      let filters = vals.map(buildFeatureFilter);  // Iteratively recursive!
      return (d) => filters.every( filt => filt(d) );
    }
    case "any": {
      let filters = vals.map(buildFeatureFilter);
      return (d) => filters.some( filt => filt(d) );
    }
    case "none": {
      let filters = vals.map(buildFeatureFilter);
      return (d) => filters.every( filt => !filt(d) );
    }
    default:
      return getSimpleFilter(filterObj);
  }
}

function getSimpleFilter(filterObj) {
  const [type, key, ...vals] = filterObj;
  const getVal = initFeatureValGetter(key);

  switch (type) {
    // Existential Filters
    case "has": 
      return d => !!getVal(d); // !! forces a Boolean return
    case "!has": 
      return d => !getVal(d);

    // Comparison Filters
    case "==": 
      return d => getVal(d) === vals[0];
    case "!=":
      return d => getVal(d) !== vals[0];
    case ">":
      return d => getVal(d) > vals[0];
    case ">=":
      return d => getVal(d) >= vals[0];
    case "<":
      return d => getVal(d) < vals[0];
    case "<=":
      return d => getVal(d) <= vals[0];

    // Set Membership Filters
    case "in" :
      return d => vals.includes( getVal(d) );
    case "!in" :
      return d => !vals.includes( getVal(d) );
    default:
      console.log("prepFilter: unknown filter type = " + filterObj[0]);
  }
  // No recognizable filter criteria. Return a filter that is always true
  return () => true;
}

function initFeatureValGetter(key) {
  switch (key) {
    case "$type":
      // NOTE: data includes MultiLineString, MultiPolygon, etc-NOT IN SPEC
      return f => {
        let t = f.geometry.type;
        if (t === "MultiPoint") return "Point";
        if (t === "MultiLineString") return "LineString";
        if (t === "MultiPolygon") return "Polygon";
        return t;
      };
    case "$id":
      return f => f.id;
    default:
      return f => f.properties[key];
  }
}

function initSourceFilter(styles) {
  const filters = styles.map(initLayerFilter);

  return function(source, z) {
    return filters.reduce((d, f) => Object.assign(d, f(source, z)), {});
  };
}

function initLayerFilter(style) {
  const { id, type, filter,
    minzoom = 0, maxzoom = 99,
    "source-layer": sourceLayer,
  } = style;

  const filterObject = composeFilters(getGeomFilter(type), filter);
  const parsedFilter = buildFeatureFilter(filterObject);

  return function(source, zoom) {
    // source is a dictionary of FeatureCollections, keyed on source-layer
    if (!source || zoom < minzoom || maxzoom < zoom) return;

    let layer = source[sourceLayer];
    if (!layer) return;

    let features = layer.features.filter(parsedFilter);
    if (features.length > 0) return { [id]: features };
  };
}

function composeFilters(filter1, filter2) {
  if (!filter1) return filter2;
  if (!filter2) return filter1;
  return ["all", filter1, filter2];
}

function getGeomFilter(type) {
  switch (type) {
    case "circle":
      return ["==", "$type", "Point"];
    case "line":
      return ["!=", "$type", "Point"]; // Could be LineString or Polygon
    case "fill":
      return ["==", "$type", "Polygon"];
    case "symbol":
      return ["==", "$type", "Point"]; // TODO: implement line geom labels
    default:
      return; // No condition on geometry
  }
}

function getTokenParser(tokenText) {
  if (!tokenText) return () => undefined;
  const tokenPattern = /{([^{}]+)}/g;

  // We break tokenText into pieces that are either plain text or tokens,
  // then construct an array of functions to parse each piece
  var tokenFuncs = [];
  var charIndex  = 0;
  while (charIndex < tokenText.length) {
    // Find the next token
    let result = tokenPattern.exec(tokenText);

    if (!result) {
      // No tokens left. Parse the plain text after the last token
      let str = tokenText.substring(charIndex);
      tokenFuncs.push(props => str);
      break;
    } else if (result.index > charIndex) {
      // There is some plain text before the token
      let str = tokenText.substring(charIndex, result.index);
      tokenFuncs.push(props => str);
    }

    // Add a function to process the current token
    let token = result[1];
    tokenFuncs.push(props => props[token]);
    charIndex = tokenPattern.lastIndex;
  }
  
  // We now have an array of functions returning either a text string or
  // a feature property
  // Return a function that assembles everything
  return function(properties) {
    return tokenFuncs.reduce(concat, "");
    function concat(str, tokenFunc) {
      let text = tokenFunc(properties) || "";
      return str += text;
    }
  };
}

function initText(parsedStyles) {
  const textGetters = parsedStyles
    .filter(s => s.type === "symbol")
    .reduce((d, s) => (d[s.id] = initTextGetter(s), d), {});

  return function(layers, zoom) {
    return Object.entries(layers).reduce((textLayers, [id, features]) => {
      const getter = textGetters[id];
      if (getter) textLayers[id] = features.map(f => getter(f, zoom));
      return textLayers;
    }, {});
  };
}

function initTextGetter(style) {
  const layout = style.layout;

  return function(feature, zoom) {
    const { geometry, properties } = feature;

    const textField = layout["text-field"](zoom, feature);
    const text = getTokenParser(textField)(properties);
    if (!text) return feature;

    const transformCode = layout["text-transform"](zoom, feature);
    const transform = getTextTransform(transformCode);

    const charCodes = transform(text).split("").map(c => c.charCodeAt(0));
    
    const font = layout["text-font"](zoom, feature);

    return { geometry, properties, font, charCodes };
  };
}

function getTextTransform(code) {
  switch (code) {
    case "uppercase":
      return f => f.toUpperCase();
    case "lowercase":
      return f => f.toLowerCase();
    case "none":
    default:
      return f => f;
  }
}

var read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

var write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var ieee754 = {
	read: read,
	write: write
};

var pbf = Pbf;



function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;

        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            // longer strings are fast with the built-in browser TextDecoder API
            return readUtf8TextDecoder(this.buf, pos, end);
        }
        // short strings are fast with our custom implementation
        return readUtf8(this.buf, pos, end);
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

class AlphaImage {
  // See mapbox-gl-js/src/util/image.js
  constructor(size, data) {
    createImage(this, size, 1, data);
  }

  resize(size) {
    resizeImage(this, size, 1);
  }

  clone() {
    return new AlphaImage(
      { width: this.width, height: this.height },
      new Uint8Array(this.data)
    );
  }

  static copy(srcImg, dstImg, srcPt, dstPt, size) {
    copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);
  }
}

function createImage(image, { width, height }, channels, data) {
  if (!data) {
    data = new Uint8Array(width * height * channels);
  } else if (data.length !== width * height * channels) {
    throw new RangeError('mismatched image size');
  }
  return Object.assign(image, { width, height, data });
}

function resizeImage(image, { width, height }, channels) {
  if (width === image.width && height === image.height) return;

  const size = { 
    width: Math.min(image.width, width),
    height: Math.min(image.height, height),
  };

  const newImage = createImage({}, { width, height }, channels);

  copyImage(image, newImage, { x: 0, y: 0 }, { x: 0, y: 0 }, size, channels);

  Object.assign(image, { width, height, data: newImage.data });
}

function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
  if (size.width === 0 || size.height === 0) return dstImg;

  if (outOfRange(srcPt, size, srcImg)) {
    throw new RangeError('out of range source coordinates for image copy');
  }
  if (outOfRange(dstPt, size, dstImg)) {
    throw new RangeError('out of range destination coordinates for image copy');
  }

  const srcData = srcImg.data;
  const dstData = dstImg.data;

  console.assert(
    srcData !== dstData,
    "copyImage: src and dst data are identical!"
  );

  for (let y = 0; y < size.height; y++) {
    const srcOffset = ((srcPt.y + y) * srcImg.width + srcPt.x) * channels;
    const dstOffset = ((dstPt.y + y) * dstImg.width + dstPt.x) * channels;
    for (let i = 0; i < size.width * channels; i++) {
      dstData[dstOffset + i] = srcData[srcOffset + i];
    }
  }

  return dstImg;
}

function outOfRange(point, size, image) {
  let { width, height } = size;
  return (
    width > image.width ||
    height > image.height ||
    point.x > image.width - width ||
    point.y > image.height - height
  );
}

const GLYPH_PBF_BORDER = 3;
const ONE_EM = 24;

function parseGlyphPbf(data) {
  // See mapbox-gl-js/src/style/parse_glyph_pbf.js
  // Input is an ArrayBuffer, which will be read as a Uint8Array
  return new pbf(data).readFields(readFontstacks, []);
}

function readFontstacks(tag, glyphs, pbf) {
  if (tag === 1) pbf.readMessage(readFontstack, glyphs);
}

function readFontstack(tag, glyphs, pbf) {
  if (tag !== 3) return;

  const glyph = pbf.readMessage(readGlyph, {});
  const { id, bitmap, width, height, left, top, advance } = glyph;

  const borders = 2 * GLYPH_PBF_BORDER;
  const size = { width: width + borders, height: height + borders };

  glyphs.push({
    id,
    bitmap: new AlphaImage(size, bitmap),
    metrics: { width, height, left, top, advance }
  });
}

function readGlyph(tag, glyph, pbf) {
  if (tag === 1) glyph.id = pbf.readVarint();
  else if (tag === 2) glyph.bitmap = pbf.readBytes();
  else if (tag === 3) glyph.width = pbf.readVarint();
  else if (tag === 4) glyph.height = pbf.readVarint();
  else if (tag === 5) glyph.left = pbf.readSVarint();
  else if (tag === 6) glyph.top = pbf.readSVarint();
  else if (tag === 7) glyph.advance = pbf.readVarint();
}

function initGlyphCache(endpoint) {
  const fonts = {};

  function getBlock(font, range) {
    const first = range * 256;
    const last = first + 255;
    const href = endpoint
      .replace('{fontstack}', font.split(" ").join("%20"))
      .replace('{range}', first + "-" + last);

    return fetch(href)
      .then(getArrayBuffer)
      .then(parseGlyphPbf)
      .then(glyphs => glyphs.reduce((d, g) => (d[g.id] = g, d), {}));
  }

  return function(font, code) {
    // 1. Find the 256-char block containing this code
    if (code > 65535) throw Error('glyph codes > 65535 not supported');
    const range = Math.floor(code / 256);

    // 2. Get the Promise for the retrieval and parsing of the block
    const blocks = fonts[font] || (fonts[font] = {});
    const block = blocks[range] || (blocks[range] = getBlock(font, range));

    // 3. Return a Promise that resolves to the requested glyph
    // NOTE: may be undefined! if the API returns a sparse or empty block
    return block.then(glyphs => glyphs[code]);
  };
}

function getArrayBuffer(response) {
  if (!response.ok) throw Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}

function potpack(boxes) {

    // calculate total box area and maximum box width
    let area = 0;
    let maxWidth = 0;

    for (const box of boxes) {
        area += box.w * box.h;
        maxWidth = Math.max(maxWidth, box.w);
    }

    // sort the boxes for insertion by height, descending
    boxes.sort((a, b) => b.h - a.h);

    // aim for a squarish resulting container,
    // slightly adjusted for sub-100% space utilization
    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);

    // start with a single empty space, unbounded at the bottom
    const spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];

    let width = 0;
    let height = 0;

    for (const box of boxes) {
        // look through spaces backwards so that we check smaller spaces first
        for (let i = spaces.length - 1; i >= 0; i--) {
            const space = spaces[i];

            // look for empty spaces that can accommodate the current box
            if (box.w > space.w || box.h > space.h) continue;

            // found the space; add the box to its top-left corner
            // |-------|-------|
            // |  box  |       |
            // |_______|       |
            // |         space |
            // |_______________|
            box.x = space.x;
            box.y = space.y;

            height = Math.max(height, box.y + box.h);
            width = Math.max(width, box.x + box.w);

            if (box.w === space.w && box.h === space.h) {
                // space matches the box exactly; remove it
                const last = spaces.pop();
                if (i < spaces.length) spaces[i] = last;

            } else if (box.h === space.h) {
                // space matches the box height; update it accordingly
                // |-------|---------------|
                // |  box  | updated space |
                // |_______|_______________|
                space.x += box.w;
                space.w -= box.w;

            } else if (box.w === space.w) {
                // space matches the box width; update it accordingly
                // |---------------|
                // |      box      |
                // |_______________|
                // | updated space |
                // |_______________|
                space.y += box.h;
                space.h -= box.h;

            } else {
                // otherwise the box splits the space into two spaces
                // |-------|-----------|
                // |  box  | new space |
                // |_______|___________|
                // | updated space     |
                // |___________________|
                spaces.push({
                    x: space.x + box.w,
                    y: space.y,
                    w: space.w - box.w,
                    h: box.h
                });
                space.y += box.h;
                space.h -= box.h;
            }
            break;
        }
    }

    return {
        w: width, // container width
        h: height, // container height
        fill: (area / (width * height)) || 0 // space utilization
    };
}

const ATLAS_PADDING = 1;

function buildAtlas(fonts) {
  // See mapbox-gl-js/src/render/glyph_atlas.js

  // Construct position objects (metrics and rects) for each glyph
  const positions = Object.entries(fonts)
    .reduce((pos, [font, glyphs]) => {
      pos[font] = getPositions(glyphs);
      return pos;
    }, {});

  // Figure out how to pack all the bitmaps into one image
  // NOTE: modifies the rects in the positions object, in place!
  const rects = Object.values(positions)
    .flatMap(fontPos => Object.values(fontPos))
    .map(p => p.rect);
  const { w, h } = potpack(rects);

  // Using the updated rects, copy all the bitmaps into one image
  const image = new AlphaImage({ width: w || 1, height: h || 1 });
  Object.entries(fonts).forEach(([font, glyphs]) => {
    let fontPos = positions[font];
    glyphs.forEach(glyph => copyGlyphBitmap(glyph, fontPos, image));
  });

  return { image, positions };
}

function getPositions(glyphs) {
  return glyphs.reduce((dict, glyph) => {
    let pos = getPosition(glyph);
    if (pos) dict[glyph.id] = pos;
    return dict;
  }, {});
}

function getPosition(glyph) {
  let { bitmap: { width, height }, metrics } = glyph;
  if (width === 0 || height === 0) return;

  // Construct a preliminary rect, positioned at the origin for now
  let w = width + 2 * ATLAS_PADDING;
  let h = height + 2 * ATLAS_PADDING;
  let rect = { x: 0, y: 0, w, h };

  return { metrics, rect };
}

function copyGlyphBitmap(glyph, positions, image) {
  let { id, bitmap, metrics } = glyph;
  let position = positions[id];
  if (!position) return;

  let srcPt = { x: 0, y: 0 };
  let { x, y } = position.rect;
  let dstPt = { x: x + ATLAS_PADDING, y: y + ATLAS_PADDING };
  AlphaImage.copy(bitmap, image, srcPt, dstPt, bitmap);
}

function initGetter(urlTemplate, key) {
  // Check if url is valid
  const urlOK = (
    (typeof urlTemplate === "string" || urlTemplate instanceof String) &&
    urlTemplate.slice(0, 4) === "http"
  );
  if (!urlOK) return console.log("sdf-manager: no valid glyphs URL!");

  // Put in the API key, if supplied
  const endpoint = (key)
    ? urlTemplate.replace('{key}', key)
    : urlTemplate;

  const getGlyph = initGlyphCache(endpoint);

  return function(fontCodes) {
    // fontCodes = { font1: [code1, code2...], font2: ... }
    const fontGlyphs = {};

    const promises = Object.entries(fontCodes).map(([font, codes]) => {
      let requests = Array.from(codes, code => getGlyph(font, code));

      return Promise.all(requests).then(glyphs => {
        fontGlyphs[font] = glyphs.filter(g => g !== undefined);
      });
    });

    return Promise.all(promises).then(() => {
      return buildAtlas(fontGlyphs);
    });
  };
}

function initGlyphs(glyphEndpoint) {
  const getAtlas = initGetter(glyphEndpoint);

  return function(layers, zoom) {
    const fonts = Object.values(layers).reduce(collectCharCodes, {});

    return getAtlas(fonts);
  };
}

function collectCharCodes(fonts, features) {
  const textFeatures = features.filter(f => f.charCodes && f.charCodes.length);
  textFeatures.forEach(f => {
    let font = fonts[f.font] || (fonts[f.font] = new Set());
    f.charCodes.forEach(font.add, font);
  });
  return fonts;
}

function getGlyphInfo(feature, atlas) {
  const { font, charCodes } = feature;
  const positions = atlas.positions[font];

  if (!positions || !charCodes || !charCodes.length) return;

  const info = feature.charCodes.map(code => {
    let pos = positions[code];
    if (!pos) return;
    let { metrics, rect } = pos;
    return { code, metrics, rect };
  });

  return info.filter(i => i !== undefined);
}

const whitespace = {
  // From mapbox-gl-js/src/symbol/shaping.js
  [0x09]: true, // tab
  [0x0a]: true, // newline
  [0x0b]: true, // vertical tab
  [0x0c]: true, // form feed
  [0x0d]: true, // carriage return
  [0x20]: true, // space
};

const breakable = {
  // From mapbox-gl-js/src/symbol/shaping.js
  [0x0a]:   true, // newline
  [0x20]:   true, // space
  [0x26]:   true, // ampersand
  [0x28]:   true, // left parenthesis
  [0x29]:   true, // right parenthesis
  [0x2b]:   true, // plus sign
  [0x2d]:   true, // hyphen-minus
  [0x2f]:   true, // solidus
  [0xad]:   true, // soft hyphen
  [0xb7]:   true, // middle dot
  [0x200b]: true, // zero-width space
  [0x2010]: true, // hyphen
  [0x2013]: true, // en dash
  [0x2027]: true  // interpunct
};

function getTextBoxShift(anchor) {
  // Shift the top-left corner of the text bounding box
  // by the returned value * bounding box dimensions
  switch (anchor) {
    case "top-left":
      return [ 0.0,  0.0];
    case "top-right":
      return [-1.0,  0.0];
    case "top":
      return [-0.5,  0.0];
    case "bottom-left":
      return [ 0.0, -1.0];
    case "bottom-right":
      return [-1.0, -1.0];
    case "bottom":
      return [-0.5, -1.0];
    case "left":
      return [ 0.0, -0.5];
    case "right":
      return [-1.0, -0.5];
    case "center":
    default:
      return [-0.5, -0.5];
  }
}

function getLineShift(justify, boxShiftX) {
  // Shift the start of the text line (left side) by the
  // returned value * (boundingBoxWidth - lineWidth)
  switch (justify) {
    case "auto":
      return -boxShiftX;
    case "left":
      return 0;
    case "right":
      return 1;
    case "center":
    default:
      return 0.5;
  }
}

function getBreakPoints(glyphs, spacing, targetWidth) {
  const potentialLineBreaks = [];
  const last = glyphs.length - 1;
  let cursor = 0;

  glyphs.forEach((g, i) => {
    let { code, metrics: { advance } } = g;
    if (!whitespace[code]) cursor += advance + spacing;

    if (i == last) return;
    if (!breakable[code] 
      //&& !charAllowsIdeographicBreaking(code)
    ) return;

    let breakInfo = evaluateBreak(
      i + 1,
      cursor,
      targetWidth,
      potentialLineBreaks,
      calculatePenalty(code, glyphs[i + 1].code),
      false
    );
    potentialLineBreaks.push(breakInfo);
  });

  const lastBreak = evaluateBreak(
    glyphs.length,
    cursor,
    targetWidth,
    potentialLineBreaks,
    0,
    true
  );

  return leastBadBreaks(lastBreak);
}

function leastBadBreaks(lastBreak) {
  if (!lastBreak) return [];
  return leastBadBreaks(lastBreak.priorBreak).concat(lastBreak.index);
}

function evaluateBreak(index, x, targetWidth, breaks, penalty, isLastBreak) {
  // Start by assuming the supplied (index, x) is the first break
  const init = {
    index, x,
    priorBreak: null,
    badness: calculateBadness(x)
  };

  // Now consider all previous possible break points, and
  // return the pair corresponding to the best combination of breaks
  return breaks.reduce((best, prev) => {
    const badness = calculateBadness(x - prev.x) + prev.badness;
    if (badness < best.badness) {
      best.priorBreak = prev;
      best.badness = badness;
    }
    return best;
  }, init);

  function calculateBadness(width) {
    const raggedness = (width - targetWidth) ** 2;

    if (!isLastBreak) return raggedness + Math.abs(penalty) * penalty;

    // Last line: prefer shorter than average
    return (width < targetWidth)
      ? raggedness / 2
      : raggedness * 2;
  }
}

function calculatePenalty(code, nextCode) {
  let penalty = 0;
  // Force break on newline
  if (code === 0x0a) penalty -= 10000;
  // Penalize open parenthesis at end of line
  if (code === 0x28 || code === 0xff08) penalty += 50;
  // Penalize close parenthesis at beginning of line
  if (nextCode === 0x29 || nextCode === 0xff09) penalty += 50;

  return penalty;
}

function splitLines(glyphs, spacing, maxWidth) {
  // glyphs is an Array of Objects with properties { code, metrics, rect }
  // spacing and maxWidth should already be scaled to the same units as
  //   glyph.metrics.advance
  const totalWidth = measureLine(glyphs, spacing);

  const lineCount = Math.ceil(totalWidth / maxWidth);
  if (lineCount < 1) return [];
  
  const targetWidth = totalWidth / lineCount;
  const breakPoints = getBreakPoints(glyphs, spacing, targetWidth);

  return breakLines(glyphs, breakPoints);
}

function measureLine(glyphs, spacing) {
  if (glyphs.length < 1) return 0;

  // No initial value for reduce--so no spacing added for 1st char
  return glyphs.map(g => g.metrics.advance)
    .reduce((a, c) => a + c + spacing);
}

function breakLines(glyphs, breakPoints) {
  let start = 0;

  return breakPoints.map(lineBreak => {
    let line = glyphs.slice(start, lineBreak);

    // Trim whitespace from both ends
    while (line.length && whitespace[line[0].code]) line.shift();
    while (trailingWhiteSpace(line)) line.pop();

    start = lineBreak;
    return line;
  });
}

function trailingWhiteSpace(line) {
  let len = line.length;
  if (!len) return false;
  return whitespace[line[len - 1].code];
}

const RECT_BUFFER = GLYPH_PBF_BORDER + ATLAS_PADDING;

function initShaping(style) {
  const layout = style.layout;

  return function(feature, zoom, atlas) {
    // For each feature, compute a list of info for each character:
    // - x0, y0  defining overall label position
    // - dx, dy  delta positions relative to label position
    // - x, y, w, h  defining the position of the glyph within the atlas

    // 1. Get the glyphs for the characters
    const glyphs = getGlyphInfo(feature, atlas);
    if (!glyphs) return;

    // 2. Split into lines
    const spacing = layout["text-letter-spacing"](zoom, feature) * ONE_EM;
    const maxWidth = layout["text-max-width"](zoom, feature) * ONE_EM;
    const lines = splitLines(glyphs, spacing, maxWidth);
    // TODO: What if no labelText, or it is all whitespace?

    // 3. Get dimensions of lines and overall text box
    const lineWidths = lines.map(line => measureLine(line, spacing));
    const lineHeight = layout["text-line-height"](zoom, feature) * ONE_EM;

    const boxSize = [Math.max(...lineWidths), lines.length * lineHeight];
    const textOffset = layout["text-offset"](zoom, feature)
      .map(c => c * ONE_EM);
    const boxShift = getTextBoxShift( layout["text-anchor"](zoom, feature) );
    const boxOrigin = boxShift.map((c, i) => c * boxSize[i] + textOffset[i]);

    // 4. Compute origins for each line
    const justify = layout["text-justify"](zoom, feature);
    const lineShiftX = getLineShift(justify, boxShift[0]);
    const lineOrigins = lineWidths.map((lineWidth, i) => {
      let x = (boxSize[0] - lineWidth) * lineShiftX + boxOrigin[0];
      let y = i * lineHeight + boxOrigin[1];
      return [x, y];
    });

    // 5. Compute top left corners of the glyphs in each line
    const deltas = lines
      .flatMap((l, i) => layoutLine(l, lineOrigins[i], spacing));

    // 6. Fill in label origins for each glyph. TODO: assumes Point geometry
    const origin = feature.geometry.coordinates.slice();
    const origins = lines.flat()
      .flatMap(g => origin);

    // 7. Collect all the glyph rects
    const rects = lines.flat()
      .flatMap(g => Object.values(g.rect));

    // 8. Compute bounding box for collision checks
    const scalar = layout["text-size"](zoom, feature) / ONE_EM;
    const textPadding = layout["text-padding"](zoom, feature);
    const bbox = [
      boxOrigin[0] * scalar - textPadding,
      boxOrigin[1] * scalar - textPadding,
      (boxOrigin[0] + boxSize[0]) * scalar + textPadding,
      (boxOrigin[1] + boxSize[1]) * scalar + textPadding
    ];

    const buffers = { origins, deltas, rects, bbox };

    return { properties: feature.properties, buffers };
  }
}

function layoutLine(glyphs, origin, spacing) {
  var xCursor = origin[0];
  const y0 = origin[1];

  return glyphs.flatMap(g => {
    let { left, top, advance } = g.metrics;

    let dx = xCursor + left - RECT_BUFFER;
    let dy = y0 - top - RECT_BUFFER;

    xCursor += advance + spacing;

    return [dx, dy];
  });
}

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

class RBush {
    constructor(maxEntries = 9) {
        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
    }

    all() {
        return this._all(this.data, []);
    }

    search(bbox) {
        let node = this.data;
        const result = [];

        if (!intersects(bbox, node)) return result;

        const toBBox = this.toBBox;
        const nodesToSearch = [];

        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    }

    collides(bbox) {
        let node = this.data;

        if (!intersects(bbox, node)) return false;

        const nodesToSearch = [];
        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? this.toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    }

    load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (let i = 0; i < data.length; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        let node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                const tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    }

    insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    }

    clear() {
        this.data = createNode([]);
        return this;
    }

    remove(item, equalsFn) {
        if (!item) return this;

        let node = this.data;
        const bbox = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i, parent, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                const index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    }

    toBBox(item) { return item; }

    compareMinX(a, b) { return a.minX - b.minX; }
    compareMinY(a, b) { return a.minY - b.minY; }

    toJSON() { return this.data; }

    fromJSON(data) {
        this.data = data;
        return this;
    }

    _all(node, result) {
        const nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push(...node.children);
            else nodesToSearch.push(...node.children);

            node = nodesToSearch.pop();
        }
        return result;
    }

    _build(items, left, right, height) {

        const N = right - left + 1;
        let M = this._maxEntries;
        let node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));

        multiSelect(items, left, right, N1, this.compareMinX);

        for (let i = left; i <= right; i += N1) {

            const right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (let j = i; j <= right2; j += N2) {

                const right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    }

    _chooseSubtree(bbox, node, level, path) {
        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            let minArea = Infinity;
            let minEnlargement = Infinity;
            let targetNode;

            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const area = bboxArea(child);
                const enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    }

    _insert(item, level, isNode) {
        const bbox = isNode ? item : this.toBBox(item);
        const insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        const node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend$1(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    }

    // split overflowed node into two
    _split(insertPath, level) {
        const node = insertPath[level];
        const M = node.children.length;
        const m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        const splitIndex = this._chooseSplitIndex(node, m, M);

        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    }

    _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    }

    _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;

        for (let i = m; i <= M - m; i++) {
            const bbox1 = distBBox(node, 0, i, this.toBBox);
            const bbox2 = distBBox(node, i, M, this.toBBox);

            const overlap = intersectionArea(bbox1, bbox2);
            const area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index || M - m;
    }

    // sorts node children by the best axis for split
    _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    }

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);

        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

        for (let i = m; i < M - m; i++) {
            const child = node.children[i];
            extend$1(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (let i = M - m - 1; i >= m; i--) {
            const child = node.children[i];
            extend$1(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    }

    _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (let i = level; i >= 0; i--) {
            extend$1(path[i], bbox);
        }
    }

    _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (let i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    }
}

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (let i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (let i = k; i < p; i++) {
        const child = node.children[i];
        extend$1(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend$1(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    const minX = Math.max(a.minX, b.minX);
    const minY = Math.max(a.minY, b.minY);
    const maxX = Math.min(a.maxX, b.maxX);
    const maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    const stack = [left, right];

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        const mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

function initSymbols({ parsedStyles, glyphEndpoint }) {
  const getText = initText(parsedStyles);
  const getGlyphs = initGlyphs(glyphEndpoint);
  const shapeText = initShapers(parsedStyles);

  return function(layers, zoom) {
    const textLayers = getText(layers, zoom);

    return getGlyphs(textLayers)
      .then(atlas => shapeText(textLayers, zoom, atlas));
  };
}

function initShapers(styles) {
  const shapers = styles
    .filter(s => s.type === "symbol")
    .reduce((d, s) => (d[s.id] = initShaping(s), d), {});

  return function(textLayers, zoom, atlas) {
    const shaped = Object.entries(textLayers).reduce((d, [id, features]) => {
      d[id] = features.map(f => shapers[id](f, zoom, atlas))
        .filter(f => f !== undefined);
      return d;
    }, {});

    const tree = new RBush();
    Object.entries(shaped).reverse().forEach(([id, features]) => {
      shaped[id] = features.filter(f => collide(f, tree));
    });

    return { atlas: atlas.image, layers: shaped };
  };
}

function collide(feature, tree) {
  // NOTE: tree will be modified!!

  let { origins, bbox } = feature.buffers;
  let [ x0, y0 ] = origins;
  let box = {
    minX: x0 + bbox[0],
    minY: y0 + bbox[1],
    maxX: x0 + bbox[2],
    maxY: y0 + bbox[3],
  };

  if (tree.collides(box)) return false;

  tree.insert(box);
  return true; // TODO: drop feature if outside tile?
}

var earcut_1 = earcut;
var default_1 = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects$1(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);

        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects$1(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects$1(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};
earcut_1.default = default_1;

function parseLine(feature) {
  const { geometry, properties } = feature;
  const buffers = { points: flattenLine(geometry) };

  return { properties, buffers };
}

function flattenLine(geometry) {
  let { type, coordinates } = geometry;

  switch (type) {
    case "LineString":
      return flattenLineString(coordinates);
    case "MultiLineString":
      return coordinates.flatMap(flattenLineString);
    case "Polygon":
      return flattenPolygon(coordinates);
    case "MultiPolygon":
      return coordinates.flatMap(flattenPolygon);
    default:
      return;
  }
}

function flattenLineString(line) {
  return [
    ...[...line[0], -2.0],
    ...line.flatMap(([x, y]) => [x, y, 0.0]),
    ...[...line[line.length - 1], -2.0]
  ];
}

function flattenPolygon(rings) {
  return rings.flatMap(flattenLinearRing);
}

function flattenLinearRing(ring) {
  // Definition of linear ring:
  // ring.length > 3 && ring[ring.length - 1] == ring[0]
  return [
    ...[...ring[ring.length - 2], -2.0],
    ...ring.flatMap(([x, y]) => [x, y, 0.0]),
    ...[...ring[1], -2.0]
  ];
}

function triangulate(feature) {
  const { geometry, properties } = feature;

  // Normalize coordinate structure
  var { type, coordinates } = geometry;
  if (type === "Polygon") {
    coordinates = [coordinates];
  } else if (type !== "MultiPolygon") {
    return feature; // Triangulation only makes sense for Polygons/MultiPolygons
  }

  const combined = coordinates
    .map(coord => {
      let { vertices, holes, dimensions } = earcut_1.flatten(coord);
      let indices = earcut_1(vertices, holes, dimensions);
      return { vertices, indices };
    })
    .reduce((accumulator, current) => {
      let indexShift = accumulator.vertices.length / 2;
      accumulator.vertices.push(...current.vertices);
      accumulator.indices.push(...current.indices.map(h => h + indexShift));
      return accumulator;
    });

  const buffers = {
    vertices: combined.vertices,
    indices: combined.indices,
    points: flattenLine(geometry), // For rendering the outline
  };

  return { properties, buffers };
}

function initFeatureGrouper(style) {
  // Find the names of the feature properties that affect rendering
  const renderPropertyNames = Object.values(style.paint)
    .filter(styleFunc => styleFunc.type === "property")
    .map(styleFunc => styleFunc.property);

  return function(features) {
    // Group features that will be styled the same
    const groups = {};
    features.forEach(feature => {
      // Keep only the properties relevant to rendering
      let properties = renderPropertyNames
        .reduce((d, k) => (d[k] = feature.properties[k], d), {});

      // Look up the appropriate group, or create it if it doesn't exist
      let key = Object.entries(properties).join();
      if (!groups[key]) groups[key] = initFeature(feature, properties);

      // Append this features buffers to the grouped feature
      appendBuffers(groups[key].buffers, feature.buffers);
    });

    return Object.values(groups).map(makeTypedArrays);
  };
}

function initFeature(template, renderProperties) {
  const properties = Object.assign({}, renderProperties);
  const buffers = Object.keys(template.buffers)
    .reduce((d, k) => (d[k] = [], d), {});

  return { properties, buffers };
}

function appendBuffers(buffers, newBuffers) {
  const appendix = Object.assign({}, newBuffers);
  if (buffers.indices) {
    let indexShift = buffers.vertices.length / 2;
    appendix.indices = newBuffers.indices.map(i => i + indexShift);
  }
  Object.keys(buffers).forEach(k => {
    // NOTE: The 'obvious' buffers[k].push(...appendix[k]) fails with
    //  the error "Maximum call stack size exceeded"
    let base = buffers[k];
    appendix[k].forEach(a => base.push(a));
  });
}

function makeTypedArrays(feature) {
  const { properties, buffers } = feature;
  // Note: modifying in place!
  Object.keys(buffers).forEach(key => {
    buffers[key] = (key === "indices")
      ? new Uint16Array(buffers[key])
      : new Float32Array(buffers[key]);
  });
  return feature;
}

function initSourceProcessor({ styles, glyphEndpoint }) {
  const parsedStyles = styles.map(getStyleFuncs);

  const sourceFilter = initSourceFilter(parsedStyles);
  const process = initProcessor(parsedStyles);
  const processSymbols = initSymbols({ parsedStyles, glyphEndpoint });
  const compressors = parsedStyles
    .reduce((d, s) => (d[s.id] = initFeatureGrouper(s), d), {});

  return function(source, zoom) {
    const rawLayers = sourceFilter(source, zoom);

    const mainTask = process(rawLayers);
    const symbolTask = processSymbols(rawLayers, zoom);

    return Promise.all([mainTask, symbolTask]).then(([layers, symbols]) => {
      // Merge symbol layers into layers dictionary
      Object.assign(layers, symbols.layers);
      // Compress features
      Object.entries(layers).forEach(([id, features]) => {
        layers[id] = compressors[id](features);
      });
      // TODO: what if there is no atlas?
      // Note: atlas.data.buffer is a Transferable
      return { atlas: symbols.atlas, layers };
    });
  };
}

function initProcessor(styles) {
  const transforms = styles.reduce((dict, style) => {
    let { id, type } = style;

    dict[id] =
      (type === "circle") ? null // TODO
      : (type === "line") ? parseLine
      : (type === "fill") ? triangulate
      : null;

    return dict;
  }, {});

  return function(layers) {
    const data = Object.entries(layers).reduce((d, [id, features]) => {
      let transform = transforms[id];
      if (transform) d[id] = features.map(transform);
      return d;
    }, {});

    return Promise.resolve(data);
  }
}

var read$1 = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

var write$1 = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var ieee754$1 = {
	read: read$1,
	write: write$1
};

var pbf$1 = Pbf$1;



function Pbf$1(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf$1.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf$1.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf$1.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf$1.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32$1 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32$1 = 1 / SHIFT_LEFT_32$1;

// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH$1 = 12;
var utf8TextDecoder$1 = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

Pbf$1.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32$1(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32$1(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32$1(this.buf, this.pos) + readUInt32$1(this.buf, this.pos + 4) * SHIFT_LEFT_32$1;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32$1(this.buf, this.pos) + readInt32$1(this.buf, this.pos + 4) * SHIFT_LEFT_32$1;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754$1.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754$1.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder$1(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;

        if (end - pos >= TEXT_DECODER_MIN_LENGTH$1 && utf8TextDecoder$1) {
            // longer strings are fast with the built-in browser TextDecoder API
            return readUtf8TextDecoder$1(this.buf, pos, end);
        }
        // short strings are fast with our custom implementation
        return readUtf8$1(this.buf, pos, end);
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf$1.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd$1(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf$1.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf$1.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf$1.Fixed32) this.pos += 4;
        else if (type === Pbf$1.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32$1(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32$1(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32$1(this.buf, val & -1, this.pos);
        writeInt32$1(this.buf, Math.floor(val * SHIFT_RIGHT_32$1), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32$1(this.buf, val & -1, this.pos);
        writeInt32$1(this.buf, Math.floor(val * SHIFT_RIGHT_32$1), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint$1(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8$1(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength$1(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754$1.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754$1.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength$1(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf$1.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint$1, arr);   },
    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint$1, arr);  },
    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean$1, arr);  },
    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat$1, arr);    },
    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble$1, arr);   },
    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32$1, arr);  },
    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32$1, arr); },
    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64$1, arr);  },
    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64$1, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf$1.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf$1.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf$1.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf$1.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf$1.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf$1.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf$1.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf$1.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf$1.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf$1.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder$1(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum$1(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum$1(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum$1(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum$1(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum$1(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum$1(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd$1(pbf) {
    return pbf.type === Pbf$1.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum$1(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint$1(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow$1(low, high, pbf);
    writeBigVarintHigh$1(high, pbf);
}

function writeBigVarintLow$1(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh$1(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength$1(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint$1(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint$1(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat$1(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble$1(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean$1(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32$1(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32$1(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64$1(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64$1(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32$1(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32$1(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32$1(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8$1(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function readUtf8TextDecoder$1(buf, pos, end) {
    return utf8TextDecoder$1.decode(buf.subarray(pos, end));
}

function writeUtf8$1(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

function classifyRings(rings) {
  // Classifies an array of rings into polygons with outer rings and holes
  if (rings.length <= 1) return [rings];

  var polygons = [];
  var polygon, ccw;

  rings.forEach(ring => {
    let area = signedArea$1(ring);
    if (area === 0) return;

    if (ccw === undefined) ccw = area < 0;

    if (ccw === area < 0) {
      if (polygon) polygons.push(polygon);
      polygon = [ring];

    } else {
      polygon.push(ring);
    }
  });
  if (polygon) polygons.push(polygon);

  return polygons;
}

function signedArea$1(ring) {
  const xmul = (p1, p2) => (p2.x - p1.x) * (p1.y + p2.y);

  const initialValue = xmul(ring[0], ring[ring.length - 1]);

  return ring.slice(1)  // NOTE: skips ring[0], shifts index
    .reduce( (sum, p1, i) => sum + xmul(p1, ring[i]), initialValue );
}

function VectorTileFeature(pbf, end, extent, keys, values) {
  // Public
  this.properties = {};
  this.extent = extent;
  this.type = 0;

  // Private
  this._pbf = pbf;
  this._geometry = -1;
  this._keys = keys;
  this._values = values;

  pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
  if (tag == 1) feature.id = pbf.readVarint();
  else if (tag == 2) readTag(pbf, feature);
  else if (tag == 3) feature.type = pbf.readVarint();
  else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
  var end = pbf.readVarint() + pbf.pos;

  while (pbf.pos < end) {
    var key = feature._keys[pbf.readVarint()],
      value = feature._values[pbf.readVarint()];
    feature.properties[key] = value;
  }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
  var pbf = this._pbf;
  pbf.pos = this._geometry;

  var end = pbf.readVarint() + pbf.pos,
    cmd = 1,
    length = 0,
    x = 0,
    y = 0,
    lines = [],
    line;

  while (pbf.pos < end) {
    if (length <= 0) {
      var cmdLen = pbf.readVarint();
      cmd = cmdLen & 0x7;
      length = cmdLen >> 3;
    }

    length--;

    if (cmd === 1 || cmd === 2) {
      x += pbf.readSVarint();
      y += pbf.readSVarint();

      if (cmd === 1) { // moveTo
        if (line) lines.push(line);
        line = [];
      }

      line.push({ x, y });

    } else if (cmd === 7) {
      // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
      if (line) line.push({ // closePolygon
        x: line[0].x,
        y: line[0].y
      });

    } else {
      throw new Error('unknown command ' + cmd);
    }
  }

  if (line) lines.push(line);

  return lines;
};

VectorTileFeature.prototype.bbox = function() {
  var pbf = this._pbf;
  pbf.pos = this._geometry;

  var end = pbf.readVarint() + pbf.pos,
  cmd = 1,
  length = 0,
  x = 0,
  y = 0,
  x1 = Infinity,
  x2 = -Infinity,
  y1 = Infinity,
  y2 = -Infinity;

  while (pbf.pos < end) {
    if (length <= 0) {
      var cmdLen = pbf.readVarint();
      cmd = cmdLen & 0x7;
      length = cmdLen >> 3;
    }

    length--;

    if (cmd === 1 || cmd === 2) {
      x += pbf.readSVarint();
      y += pbf.readSVarint();
      if (x < x1) x1 = x;
      if (x > x2) x2 = x;
      if (y < y1) y1 = y;
      if (y > y2) y2 = y;

    } else if (cmd !== 7) {
      throw new Error('unknown command ' + cmd);
    }
  }

  return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(size, sx = 0, sy = 0) {
  // Input size is the side length of the (square) area over which the
  //  coordinate space of this tile [0, this.extent] will be rendered.
  // Input sx, sy is the origin (top left corner) of the output coordinates
  //  within the (size x size) rendered area of the full tile.

  size = size || this.extent;
  var scale = size / this.extent,
    coords = this.loadGeometry(),
    type = VectorTileFeature.types[this.type];

  function project(line) {
    return line.map(p => [p.x * scale - sx, p.y * scale - sy]);
  }

  switch (type) {
    case "Point":
      coords = project( coords.map(p => p[0]) );
      break;

    case "LineString":
      coords = coords.map(project);
      break;

    case "Polygon":
      coords = classifyRings(coords);
      coords = coords.map(polygon => polygon.map(project));
      break;
  }

  if (coords.length === 1) {
    coords = coords[0];
  } else {
    type = 'Multi' + type;
  }

  var result = {
    type: "Feature",
    geometry: {
      type: type,
      coordinates: coords
    },
    properties: this.properties
  };

  if ('id' in this) result.id = this.id;

  return result;
};

function VectorTileLayer(pbf, end) {
  // Public
  this.version = 1;
  this.name = null;
  this.extent = 4096;
  this.length = 0;

  // Private
  this._pbf = pbf;
  this._keys = [];
  this._values = [];
  this._features = [];

  pbf.readFields(readLayer, this, end);

  this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
  if (tag === 15) layer.version = pbf.readVarint();
  else if (tag === 1) layer.name = pbf.readString();
  else if (tag === 5) layer.extent = pbf.readVarint();
  else if (tag === 2) layer._features.push(pbf.pos);
  else if (tag === 3) layer._keys.push(pbf.readString());
  else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
  var value = null,
  end = pbf.readVarint() + pbf.pos;

  while (pbf.pos < end) {
    var tag = pbf.readVarint() >> 3;

    value = tag === 1 ? pbf.readString() :
      tag === 2 ? pbf.readFloat() :
      tag === 3 ? pbf.readDouble() :
      tag === 4 ? pbf.readVarint64() :
      tag === 5 ? pbf.readVarint() :
      tag === 6 ? pbf.readSVarint() :
      tag === 7 ? pbf.readBoolean() : null;
  }

  return value;
}

// return feature 'i' from this layer as a 'VectorTileFeature'
VectorTileLayer.prototype.feature = function(i) {
  if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

  this._pbf.pos = this._features[i];

  var end = this._pbf.readVarint() + this._pbf.pos;
  return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

VectorTileLayer.prototype.toGeoJSON = function(size, sx, sy) {
  const features = Array.from(Array(this._features.length), (v, i) => {
    return this.feature(i).toGeoJSON(size, sx, sy);
  });

  return { type: "FeatureCollection", features };
};

function VectorTile(pbf, end) {
  this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
  if (tag === 3) {
    var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
    if (layer.length) layers[layer.name] = layer;
  }
}

function readMVT(dataHref, size, callback) {
  // Input dataHref is the path to a file containing a Mapbox Vector Tile

  return xhrGet(dataHref, "arraybuffer", parseMVT);

  function parseMVT(err, data) {
    if (err) return callback(err, data);
    const tile = new VectorTile(new pbf$1(data));
    callback(null, mvtToJSON(tile, size));
  }
}

function mvtToJSON(tile, size) {
  const jsonLayers = {};
  Object.values(tile.layers).forEach(layer => {
    jsonLayers[layer.name] = layer.toGeoJSON(size);
  });
  return jsonLayers;
}

function xhrGet(href, type, callback) {
  var req = new XMLHttpRequest();
  req.responseType = type;

  req.onerror = errHandler;
  req.onabort = errHandler;
  req.onload = loadHandler;

  req.open('get', href);
  req.send();

  function errHandler(e) {
    let err = "XMLHttpRequest ended with an " + e.type;
    return callback(err);
  }
  function loadHandler(e) {
    if (req.responseType !== type) {
      let err = "XMLHttpRequest: Wrong responseType. Expected " +
        type + ", got " + req.responseType;
      return callback(err, req.response);
    }
    if (req.status !== 200) {
      let err = "XMLHttpRequest: HTTP " + req.status + " error from " + href;
      return callback(err, req.response);
    }
    return callback(null, req.response);
  }

  return req; // Request can be aborted via req.abort()
}

const tasks = {};
var filter = (data) => data;

onmessage = function(msgEvent) {
  // The message DATA as sent by the parent thread is now a property 
  // of the message EVENT. See
  // https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent
  const { id, type, payload } = msgEvent.data;

  switch (type) {
    case "styles":
      // NOTE: changing global variable!
      filter = initSourceProcessor(payload);
      break;
    case "start":
      let callback = (err, result) => process(id, err, result, payload.zoom);
      let request  = readMVT(payload.href, payload.size, callback);
      tasks[id] = { request, status: "requested" };
      break;
    case "cancel":
      let task = tasks[id];
      if (task && task.status === "requested") task.request.abort();
      delete tasks[id];
      break;
      // Bad message type!
  }
};

function process(id, err, result, zoom) {
  // Make sure we still have an active task for this ID
  let task = tasks[id];
  if (!task) return;  // Task must have been canceled

  if (err) {
    delete tasks[id];
    return postMessage({ id, type: "error", payload: err });
  }

  task.status = "parsing";
  return filter(result, zoom).then(tile => sendTile(id, tile));
}

function sendTile(id, tile) {
  // Make sure we still have an active task for this ID
  let task = tasks[id];
  if (!task) return; // Task must have been canceled

  // Get a list of all the Transferable objects
  const transferables = Object.values(tile.layers)
    .flatMap(features => features.flatMap(getFeatureBuffers));
  transferables.push(tile.atlas.data.buffer);

  postMessage({ id, type: "data", payload: tile }, transferables);
}

function getFeatureBuffers(feature) {
  return Object.values(feature.buffers).map(b => b.buffer);
}
`;

  function initTileMixer(userParams) {
    const params = setParams(userParams);
    const queue = params.queue;

    // Initialize workers
    const workerPath = URL.createObjectURL( new Blob([workerCode]) );
    const workers = initWorkers(workerPath, params);
    URL.revokeObjectURL(workerPath);

    const getPrepFuncs = initDataPrep(params.layers, params.context);

    // Define request function
    function request({ z, x, y, getPriority, callback }) {
      const reqHandle = {};

      const readInfo = { 
        href: params.getURL(z, x, y),
        size: 512, 
        zoom: z 
      };
      const readTaskId = workers.startTask(readInfo, prepData);
      reqHandle.abort = () => workers.cancelTask(readTaskId);

      function prepData(err, source) {
        if (err) return callback(err);

        const chunks = getPrepFuncs(source, z);
        chunks.push( () => callback(null, source) );

        const prepTaskId = queue.enqueueTask({ getPriority, chunks });

        if (params.verbose) {
          console.log("tile-mixer: " + 
            "tileID " + [z, x, y].join("/") + ", " +
            "chunks.length = " + chunks.length + ", " +
            "prepTaskId = " + prepTaskId
          );
        }

        reqHandle.abort = () => queue.cancelTask(prepTaskId);
      }

      return reqHandle;
    }

    // Return API
    return {
      request,
      activeTasks: () => workers.activeTasks() + queue.countTasks(),
      workerTasks: () => workers.activeTasks(),
      queuedTasks: () => queue.countTasks(),
      terminate: () => workers.terminate(),
    };
  }

  function initCache({ create, size = 512 }) {
    const tiles = {};
    const dzmax = Math.log2(size);

    function getOrCreateTile(zxy) {
      let id = zxy.join("/");
      if (tiles[id]) return tiles[id];

      let tile = create(...zxy); // TODO: review create signature
      if (tile) tiles[id] = tile;
      return tile;
    }

    return { retrieve, process, drop };

    function retrieve(zxy, condition) {
      let z = zxy[0];
      if (!condition) condition = ([pz]) => (pz < 0 || (z - pz) > dzmax);

      return getTileOrParent(zxy, 0, 0, size, condition);
    }

    function getTileOrParent(
      zxy,        // Coordinates of the requested tile (could be more than 3D)
      sx, sy, sw, // Cropping parameters--which part of the tile to use
      condition   // Stopping criterion for recursion
    ) {

      let tile = getOrCreateTile(zxy);
      if (!tile) return; // can't create tile for this zxy
      if (tile.ready) return { tile, sx, sy, sw };

      // Get coordinates of the parent tile
      let [z, x, y] = zxy;
      let pz = z - 1;
      let px = Math.floor(x / 2);
      let py = Math.floor(y / 2);
      let pzxy = [pz, px, py, ...zxy.slice(3)]; // Include extra coords, if any

      if (condition(pzxy)) return;

      // Compute cropping parameters for the parent
      let psx = sx / 2 + (x / 2 - px) * size;
      let psy = sy / 2 + (y / 2 - py) * size;
      let psw = sw / 2;

      return getTileOrParent(pzxy, psx, psy, psw, condition);
    }

    function process(func) {
      Object.values(tiles).forEach( tile => func(tile) );
    }

    function drop(condition) {
      var numTiles = 0;
      for (let id in tiles) {
        if (condition(tiles[id])) {
          tiles[id].cancel();
          delete tiles[id];
        } else {
          numTiles ++;
        }
      }
      return numTiles;
    }
  }

  function defaultScale(t) {
    return t.k;
  }

  function defaultTranslate(t) {
    return [t.x, t.y];
  }

  function constant(x) {
    return function() {
      return x;
    };
  }

  function tile() {
    let minZoom = 0, maxZoom = 30;
    let x0 = 0, y0 = 0, x1 = 960, y1 = 500;
    let clampX = true, clampY = true;
    let tileSize = 256;
    let scale = defaultScale;
    let translate = defaultTranslate;
    let zoomDelta = 0;

    function tile() {
      const scale_ = +scale.apply(this, arguments);
      const translate_ = translate.apply(this, arguments);
      const z = Math.log2(scale_ / tileSize);
      const z0 = Math.round(Math.min(Math.max(minZoom, z + zoomDelta), maxZoom));
      const k = Math.pow(2, z - z0) * tileSize;
      const x = +translate_[0] - scale_ / 2;
      const y = +translate_[1] - scale_ / 2;
      const xmin = Math.max(clampX ? 0 : -Infinity, Math.floor((x0 - x) / k));
      const xmax = Math.min(clampX ? 1 << z0 : Infinity, Math.ceil((x1 - x) / k));
      const ymin = Math.max(clampY ? 0 : -Infinity, Math.floor((y0 - y) / k));
      const ymax = Math.min(clampY ? 1 << z0 : Infinity, Math.ceil((y1 - y) / k));
      const tiles = [];
      for (let y = ymin; y < ymax; ++y) {
        for (let x = xmin; x < xmax; ++x) {
          tiles.push([x, y, z0]);
        }
      }
      tiles.translate = [x / k, y / k];
      tiles.scale = k;
      return tiles;
    }

    tile.size = function(_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], tile) : [x1 - x0, y1 - y0];
    };

    tile.extent = function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], tile) : [[x0, y0], [x1, y1]];
    };

    tile.scale = function(_) {
      return arguments.length ? (scale = typeof _ === "function" ? _ : constant(+_), tile) : scale;
    };

    tile.translate = function(_) {
      return arguments.length ? (translate = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), tile) : translate;
    };

    tile.zoomDelta = function(_) {
      return arguments.length ? (zoomDelta = +_, tile) : zoomDelta;
    };

    tile.minZoom = function(_) {
      return arguments.length ? (minZoom = +_, tile) : minZoom;
    };

    tile.maxZoom = function(_) {
      return arguments.length ? (maxZoom = +_, tile) : maxZoom;
    };

    tile.tileSize = function(_) {
      return arguments.length ? (tileSize = +_, tile) : tileSize;
    };

    tile.clamp = function(_) {
      return arguments.length ? (clampX = clampY = !!_, tile) : clampX && clampY;
    };

    tile.clampX = function(_) {
      return arguments.length ? (clampX = !!_, tile) : clampX;
    };

    tile.clampY = function(_) {
      return arguments.length ? (clampY = !!_, tile) : clampY;
    };

    return tile;
  }

  function tileWrap([x, y, z]) {
    const j = 1 << z;
    return [x - Math.floor(x / j) * j, y - Math.floor(y / j) * j, z];
  }

  function getTileMetric(layout, tileset, padding = 0.595) {
    const zoom = tileset[0][2];
    const nTiles = 2 ** zoom;
    const tileLength = tileset.scale; // Length of one tile in pixels
    const mapResolution = layout.tileSize() / tileLength;

    function wrap(x, xmax) {
      while (x < 0) x += xmax;
      while (x >= xmax) x -= xmax;
      return x;
    }

    // Map is viewport + padding. Store the map cornerpoints in tile units
    const [vpWidth, vpHeight] = layout.size();
    const pad = padding * mapResolution; // In tile units
    const x0 = wrap(-tileset.translate[0] - pad, nTiles);
    const x1 = x0 + vpWidth / tileLength + 2 * pad; // May cross antimeridian
    const y0 = -tileset.translate[1] - pad;
    const y1 = y0 + vpHeight / tileLength + 2 * pad;

    return function(tile) {
      let zoomFac = 2 ** (zoom - tile.z);
      let tileResolution = Math.min(1, mapResolution / zoomFac);

      // Convert the tile cornerpoints to tile units at MAP zoom level
      let tb = {
        x0: tile.x * zoomFac,
        x1: (tile.x + 1) * zoomFac,
        y0: tile.y * zoomFac,
        y1: (tile.y + 1) * zoomFac
      };

      // Find intersections of map and tile. Be careful with the antimeridian
      let xOverlap = Math.max(
        // Test for intersection with the tile in its raw position
        Math.min(x1, tb.x1) - Math.max(x0, tb.x0),
        // Test with the tile shifted across the antimeridian
        Math.min(x1, tb.x1 + nTiles) - Math.max(x0, tb.x0 + nTiles)
      );
      let yOverlap = Math.min(y1, tb.y1) - Math.max(y0, tb.y0);
      let overlapArea = Math.max(0, xOverlap) * Math.max(0, yOverlap);
      let visibleArea = overlapArea / mapResolution ** 2;

      // Flip sign to put most valuable tiles at the minimum. TODO: unnecessary?
      return 1.0 - visibleArea * tileResolution;
    };
  }

  function initSource({ source, tileFactory }) {
    const { tileSize = 512, minzoom = 0, maxzoom = 30 } = source;
    const cache = initCache({ create: tileFactory, size: tileSize });
    var numTiles = 0;

    // Set up the tile layout
    const layout = tile()
      .tileSize(tileSize * Math.sqrt(2)) // Don't let d3-tile squeeze the tiles
      .maxZoom(maxzoom)
      .clampX(false); // Allow panning across the antimeridian

    function getTiles(viewport, transform, pixRatio = 1) {
      // Get the grid of tiles needed for the current viewport
      layout.size(viewport);
      const tiles = layout(transform);

      // Update tile priorities based on the new grid
      const metric = getTileMetric(layout, tiles);
      cache.process(tile => { tile.priority = metric(tile); });
      numTiles = cache.drop(tile => metric(tile) > 0.75);
      const stopCondition = ([z, x, y]) => metric({ z, x, y }) > 0.75;

      // Retrieve a tile box for every tile in the grid
      const grid = tiles.map(([x, y, z]) => {
        let [xw, yw, zw] = tileWrap([x, y, z]);
        let box = cache.retrieve([zw, xw, yw], stopCondition);
        if (!box) return;
        // Add tile indices to returned box
        return Object.assign(box, { x, y, z });
      });

      // Find the fraction of tiles that are fully loaded
      grid.loaded = grid.reduce((frac, box) => {
        if (!box) return frac;
        return frac + (box.sw / tileSize) ** 2;
      }, 0) / grid.length;

      // Avoid seams between tiles: round coordinate transform to the nearest pixel
      // TODO: Is this problematic when we have varying tile sizes across sources?
      const scale = grid.scale = Math.round(tiles.scale * pixRatio);
      grid.translate = tiles.translate.map(x => Math.round(x * scale) / scale);

      return grid;
    }

    return { getTiles, numTiles: () => numTiles };
  }

  function initSources(style, context) {
    const { glyphs, sources, layers } = style;

    const queue = init();
    const workerMonitors = [];
    const reporter = document.createElement("div");

    const getters = Object.entries(sources).reduce((dict, [key, source]) => {
      let loader = (source.type === "vector")
        ? initVectorLoader(key, source)
        : initRasterLoader(source);
      let tileFactory = buildFactory({ source, loader, reporter });
      dict[key] = initSource({ source, tileFactory });
      return dict;
    }, {});

    function initVectorLoader(key, source) {
      let subset = layers.filter(
        l => l.source === key && l.type !== "fill-extrusion"
      );
      let loader = initTileMixer({
        context,
        glyphs, 
        source, 
        layers: subset, 
        queue,
      });
      workerMonitors.push(loader.workerTasks);
      return loader;
    }

    function getTilesets(viewport, transform, pixRatio = 1) {
      const tilesets = Object.entries(getters).reduce((dict, [key, getter]) => {
        dict[key] = getter.getTiles(viewport, transform, pixRatio);
        return dict;
      }, {});
      queue.sortTasks();
      return tilesets;
    }

    return {
      getTilesets,
      workerTasks: () => workerMonitors.reduce((s, mon) => s + mon(), 0),
      queuedTasks: () => taskQueue.countTasks(),
      reporter,
    };
  }

  function initBackgroundFill(layout, paint) {
    return function(ctx, zoom) {
      ctx.fillStyle = paint["background-color"](zoom);
      ctx.globalAlpha = paint["background-opacity"](zoom);
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  }

  function initRasterFill(layout, paint, canvSize) {
    return function(ctx, zoom, image) {
      ctx.globalAlpha = paint["raster-opacity"](zoom);
      // TODO: is canvSize necessary?
      // With the mapPainter method, coordinates are already
      // scaled to draw the tile at the correct size
      ctx.drawImage(image, 0, 0, canvSize, canvSize);
    }
  }

  function canv(property) {
    // Create a default state setter for a Canvas 2D renderer
    return (val, ctx) => { ctx[property] = val; };
  }

  function scaleCanv(property) {
    // Canvas 2D state setter with compensation for scaling
    return (val, ctx, scale = 1) => { ctx[property] = val / scale; };
  }

  function pair(getStyle, setState) {
    // Return a style value getter and a renderer state setter as a paired object
    return { getStyle, setState };
  }

  function initBrush({ setters, methods }) {
    const dataFuncs = setters.filter(s => s.getStyle.type === "property");
    const zoomFuncs = setters.filter(s => s.getStyle.type !== "property");

    return function(ctx, zoom, data, atlas, scale) {
      // Set the non-data-dependent context state
      zoomFuncs.forEach(f => f.setState(f.getStyle(zoom), ctx, scale));
      if (atlas) ctx.font = atlas;

      // Loop over features and draw
      data.forEach(feature => drawFeature(ctx, zoom, feature, scale));
    }

    function drawFeature(ctx, zoom, feature, scale) {
      // Set data-dependent context state
      dataFuncs.forEach(f => f.setState(f.getStyle(zoom, feature), ctx, scale));

      // Draw path
      methods.forEach(method => ctx[method](feature.path));
    }
  }

  function makePatternSetter(sprite) {
    const { image, meta } = sprite;
    const pCanvas = document.createElement("canvas");
    const pCtx = pCanvas.getContext("2d");

    return function(spriteID, ctx) {
      const { x, y, width, height } = meta[spriteID];
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx.drawImage(image, x, y, width, height, 0, 0, width, height);
      ctx.fillStyle = ctx.createPattern(pCanvas, "repeat");
    };
  }

  function initCircle(layout, paint) {
    const setRadius = (radius, ctx, scale = 1) => {
      ctx.lineWidth = radius * 2 / scale;
    };
    const setters = [
      pair(paint["circle-radius"],  setRadius),
      pair(paint["circle-color"],   canv("strokeStyle")),
      pair(paint["circle-opacity"], canv("globalAlpha")),
      pair(() => "round",           canv("lineCap")),
    ];
    const methods = ["stroke"];

    return initBrush({ setters, methods });
  }

  function initLine(layout, paint) {
    const setters = [
      pair(layout["line-cap"],      canv("lineCap")),
      pair(layout["line-join"],     canv("lineJoin")),
      pair(layout["line-miter-limit"], canv("miterLimit")),
      // line-round-limit,

      pair(paint["line-width"],     scaleCanv("lineWidth")),
      pair(paint["line-opacity"],   canv("globalAlpha")),
      pair(paint["line-color"],     canv("strokeStyle")),
      // line-gap-width, 
      // line-translate, line-translate-anchor,
      // line-offset, line-blur, line-gradient, line-pattern, 
    ];

    let dasharray = paint["line-dasharray"];
    if (dasharray.type !== "constant" || dasharray() !== undefined) {
      const getWidth = paint["line-width"];
      const getDash = (zoom, feature) => {
        let width = getWidth(zoom, feature);
        let dashes = dasharray(zoom, feature);
        return dashes.map(d => d * width);
      };
      const setDash = (dash, ctx, scale = 1) => {
        ctx.setLineDash(dash.map(d => d / scale));
      };
      setters.push( pair(getDash, setDash) );
    }  const methods = ["stroke"];

    return initBrush({ setters, methods });
  }

  function initFill(layout, paint, sprite) {
    var getStyle, setState;

    let pattern = paint["fill-pattern"];
    if (pattern.type !== "constant" || pattern() !== undefined) {
      // Fill with a repeated sprite. Style getter returns sprite name
      getStyle = pattern;
      setState = makePatternSetter(sprite);
    } else {
      // Fill with a solid color
      getStyle = paint["fill-color"];
      setState = canv("fillStyle");
    }

    const setTranslate = (t, ctx, scale = 1) => {
      ctx.translate(t[0] / scale, t[1] / scale);
    };
    const setters = [
      pair(getStyle, setState),
      pair(paint["fill-opacity"],   canv("globalAlpha")),
      pair(paint["fill-translate"], setTranslate),
      // fill-translate-anchor,
    ];
    const methods = ["fill"];

    let outline = paint["fill-outline-color"];
    if (outline.type !== "constant" || outline() !== undefined) {
      setters.push(
        pair(paint["fill-outline-color"], canv("strokeStyle")),
        pair(paint["fill-outline-width"], scaleCanv("lineWidth")), // nonstandard
      );
      methods.push("stroke");
    }

    return initBrush({ setters, methods });
  }

  function initSymbol(layout, paint, sprite) {
    const setters = [
      pair(layout["text-size"], scaleCanv("fontSize")),

      pair(paint["text-color"], canv("fillStyle")),
      pair(paint["text-opacity"], canv("globalAlpha")),

      pair(paint["text-halo-color"], canv("strokeStyle")),
    ];

    const methods = ["fillText"];

    return initBrush({ setters, methods });
  }

  function initRenderer(style, sprite, canvasSize) {
    const  { type, layout, paint } = style;

    switch (type) {
      case "background":
        return initBackgroundFill(layout, paint);
      case "raster":
        return initRasterFill(layout, paint, canvasSize);
      case "symbol":
        return initSymbol(layout, paint);
      case "circle":
        return initCircle(layout, paint);
      case "line":
        return initLine(layout, paint);
      case "fill":
        return initFill(layout, paint, sprite);
      case "fill-extrusion":
      case "heatmap":
      case "hillshade":
      default:
        return console.log("ERROR in initRenderer: layer.type = " +
          style.type + " not supported!");
    }
  }

  function initMapPainter(params) {
    const { context, styleLayer, spriteObject, tileSize = 512 } = params;

    const painter = initRenderer(styleLayer, spriteObject, tileSize);
    if (!painter) return () => null;

    // TODO: should maxzoom be limited to 24? See the Mapbox style spec
    const { id, type, source, minzoom = 0, maxzoom = 99 } = styleLayer;

    const getData = (type === "raster")
      ? (tile) => tile 
      : (tile) => tile.layers[id];

    const clipRect = context.clipRect || clip2d;

    const paint = (type === "background")
      ? paintBackground
      : paintTile;

    Object.assign(paint, { id, type, source, minzoom, maxzoom });

    function paintBackground({ zoom }) {
      // Background layer: just fill the whole canvas, no transform or clip
      context.save();
      painter(context, zoom); // No data needed
      context.restore();
    }

    function paintTile({ source, position, crop, zoom, pixRatio = 1 }) {
      // Input source is one tile's data for a single source,
      // which for vector sources, could include multiple layers
      let data = getData(source);
      if (!data) return false;

      context.save();

      // Set clipping mask, to limit rendering to the desired output area
      clipRect(position.x, position.y, position.w, position.w);

      // Transform coordinates to align the crop portion of the source
      // with the target position on the canvas
      let scale = position.w / crop.w;
      let tx = position.x - scale * crop.x;
      let ty = position.y - scale * crop.y;
      context.setTransform(scale, 0, 0, scale, tx, ty);

      let styleScale = scale / pixRatio;
      painter(context, zoom, data, source.atlas, styleScale);

      context.restore();
      return true; // Indicate that canvas has changed
    }

    function clip2d(x, y, width, height) {
      let area = new Path2D();
      area.rect(x, y, width, height);
      context.clip(area);
    }

    return paint;
  }

  function initRenderer$1(context, style, getTilesets) {
    const { sources, spriteData: spriteObject, layers } = style;

    const painters = layers.map(getStyleFuncs).map(styleLayer => {
      let source = sources[styleLayer.source];
      let tileSize = source ? source.tileSize : 512;
      return initMapPainter({ context, styleLayer, spriteObject, tileSize });
    });

    function drawLayers(transform, pixRatio = 1) {
      const { width, height } = context.canvas;

      // Use 'CSS pixel' size for finding the tiles to display
      const viewport = [ width / pixRatio, height / pixRatio ];
      const tilesets = getTilesets(viewport, transform, pixRatio);

      const tilesetVals = Object.values(tilesets);
      const loadStatus = tilesetVals.map(t => t.loaded)
        .reduce((s, l) => s + l) / tilesetVals.length;

      // Zoom for styling is always based on tilesize 512px (2^9) in CSS pixels
      const zoom = Math.log2(transform.k) - 9;

      context.bindFramebufferAndSetViewport();
      context.clear();
      painters.forEach(painter => {
        if (zoom < painter.minzoom || painter.maxzoom < zoom) return;
        drawLayer(painter, zoom, tilesets[painter.source], pixRatio);
      });

      return loadStatus;
    }

    function drawLayer(painter, zoom, tileset, pixRatio) {
      // No tiles for background layers
      if (!tileset) return painter({ zoom });

      let { translate: [tx, ty], scale } = tileset;
      for (const tileBox of tileset) {
        if (!tileBox) continue;

        let position = {
  	x: (tileBox.x + tx) * scale,
  	y: (tileBox.y + ty) * scale,
  	w: scale,
        };

        painter({
  	source: tileBox.tile.data,
  	position,
  	crop: { x: tileBox.sx, y: tileBox.sy, w: tileBox.sw },
  	zoom,
  	pixRatio,
        });
      }
    }

    return drawLayers;
  }

  function initEventHandler() {
    // Stores events and listeners. Listeners will be executed even if
    // the event occurred before the listener was added

    const events = {};    // { type1: data1, type2: data2, ... }
    const listeners = {}; // { type1: { id1: func1, id2: func2, ...}, type2: ... }
    var globalID = 0;

    function emitEvent(type, data = "1") {
      events[type] = data;

      let audience = listeners[type];
      if (!audience) return;

      Object.values(audience).forEach(listener => listener(data));
    }

    function addListener(type, listener) {
      if (!listeners[type]) listeners[type] = {};

      let id = ++globalID;
      listeners[type][id] = listener;
      
      if (events[type]) listener(events[type]);
      return id;
    }

    function removeListener(type, id) {
      let audience = listeners[type];
      if (audience) delete audience[id];
    }

    return {
      emitEvent,
      addListener,
      removeListener,
    };
  }

  function init$2(userParams) {
    const gl = userParams.gl;
    const { 
      framebuffer = null,
      framebufferSize = gl.canvas, // { width, height }
      style, mapboxToken,
    } = userParams;

    const context = initGLpaint(gl, framebuffer, framebufferSize);
    const eventHandler = initEventHandler();

    // Set up dummy API
    const api = {
      gl,
      size: framebufferSize,
      draw: () => null,
      when: eventHandler.addListener,
    };

    // Get style document, parse
    api.promise = loadStyle(style, mapboxToken)
      .then( styleDoc => setup(styleDoc, context, eventHandler, api) );

    return api;
  }

  function setup(styleDoc, context, eventHandler, api) {
    const sources = initSources(styleDoc, context);

    sources.reporter.addEventListener("tileLoaded", 
      () => eventHandler.emitEvent("tileLoaded"),
      false);

    api.draw = initRenderer$1(context, styleDoc, sources.getTilesets);
    
    return api;
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat$1 = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;
  const clipLat$1 = (lat) => Math.min(Math.max(-maxMercLat$1, lat), maxMercLat$1);

  function scale(geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface.
    // Return value scales a (differential) distance along the plane tangent to
    // the sphere at position <geodetic> to a distance in map coordinates.
    // NOTE: ASSUMES a sphere of radius 1! Input distances should be
    //  pre-normalized by the appropriate radius
    return 1 / (2 * Math.PI * Math.cos( clipLat$1(geodetic[1]) ));
  }

  function lonLatToXY$1(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX$1( geodetic[0] );
    projected[1] = latToY$1( geodetic[1] );
    return projected;
  }

  function lonToX$1(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY$1(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = maxMercLat, y = 1 at lat = -maxMercLat
    var y = 0.5 - 0.5 / Math.PI *
      Math.log( Math.tan(Math.PI / 4.0 + clipLat$1(lat) / 2.0) );

    return Math.min(Math.max(0.0, y), 1.0); // Y does not wrap around
  }

  function initMap(gl) {
    // Wrapper for maps. Handles projection of spherical coordinates
    const frame = initFramebuffer(gl, 1024, 1024);

    return init$2({
      gl,
      framebuffer: frame.buffer,
      framebufferSize: frame.size,
      style: "mapbox://styles/mapbox/streets-v8",
      mapboxToken: "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA",
    }).promise.then(api => setup$1(api, frame))
      .catch(console.log);
  }

  function setup$1(api, frame) {
    var loadStatus = 0;
    const { gl, size } = api;
    const transform = { k: 1, x: 0, y: 0 };

    // Construct the maps.textures object
    const texture = {
      sampler: frame.sampler,
      camPos: new Float64Array([0.5, 0.5]),
      scale: new Float64Array(2),
      changed: true,
    };

    return {
      texture,
      loaded: () => loadStatus,
      draw,
    };

    function draw(camPos, radius, view) {
      const viewport = [size.width, size.height];

      // Get map zoom
      let dMap = camPos[2] / radius *        // Normalize to radius = 1
        view.topEdge() * 2 / view.height() * // ray tangent per pixel
        scale(camPos);            // Scale assumes sphere radius = 1

      let k = 1.0 / dMap;

      let [x, y] = lonLatToXY$1([], camPos)
        .map((c, i) => (0.5 - c) * k + viewport[i] / 2);

      Object.assign(transform, { k, x, y });

      texture.scale[0] = 1.0 / (size.width * dMap);
      texture.scale[1] = 1.0 / (size.height * dMap);

      const target = gl.TEXTURE_2D;
      loadStatus = api.draw(transform);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(target, frame.sampler);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.generateMipmap(target);
      setTextureAnisotropy(gl, target);
      //gl.bindTexture(gl.TEXTURE_2D, null);
    }
  }

  function setTextureAnisotropy(gl, target) {
    var ext = (
        gl.getExtension('EXT_texture_filter_anisotropic') ||
        gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
        gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        );
    if (ext) {
      var maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      // BEWARE: this texParameterf call is slow on Intel integrated graphics.
      // Avoid this entire function if at all possible.
      gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT,
          maxAnisotropy);
    }
    return;
  }

  function setParams$1(userParams) {
    const {
      gl,
      pixelRatio,
      globeRadius = 6371,
      map,
      flipY = false,
    } = userParams;

    const getPixelRatio = (pixelRatio)
      ? () => userParams.pixelRatio
      : () => window.devicePixelRatio;
    // NOTE: getPixelRatio() returns the result of an object getter,
    //       NOT the property value at the time of getPixelRatio definition
    //  Thus, getPixelRatio will mirror any changes in the parent object

    const maps = Array.isArray(map)
      ? map
      : [map];
    const nMaps = maps.length;

    if (!(gl instanceof WebGLRenderingContext)) {
      throw("satellite-view: no valid WebGLRenderingContext!");
    }

    return { gl, getPixelRatio, globeRadius, maps, nMaps, flipY };
  }

  function resizeCanvasToDisplaySize(canvas, multiplier) {
    // Make sure the canvas drawingbuffer is the same size as the display
    // webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

    // multiplier allows scaling. Example: multiplier = window.devicePixelRatio
    if (!multiplier || multiplier < 0) multplier = 1;

    const width = Math.floor(canvas.clientWidth * multiplier);
    const height = Math.floor(canvas.clientHeight * multiplier);

    // Exit if no change
    if (canvas.width === width && canvas.height === height) return false;

    // Resize drawingbuffer to match resized display
    canvas.width = width;
    canvas.height = height;
    return true;
  }

  function initQuadBuffers(gl) {
    // 4 vertices at the corners of the quad
    const vertices = [ -1, -1,  0,    1, -1,  0,    1,  1,  0,   -1,  1,  0 ];
    // Store byte info and load into GPU
    const vertexPositions = {
      buffer: gl.createBuffer(),
      numComponents: 3,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    // Bind to the gl context
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositions.buffer);
    // Pass the array into WebGL
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Texture coordinates assume image has 0,0 at top left
    const texCoordData = [ 0, 1,   1, 1,   1, 0,   0, 0 ];
    const texCoords = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoords.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoordData), gl.STATIC_DRAW);

    // Index into two triangles
    var indices = [ 0,  1,  2,    2,  3,  0 ];
    const vertexIndices = {
      buffer: gl.createBuffer(),
      vertexCount: indices.length,
      type: gl.UNSIGNED_SHORT,
      offset: 0
    };
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndices.buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    return {
      attributes: {
        aVertexPosition: vertexPositions,
        aTexCoord: texCoords,
      },
      indices: vertexIndices,
    };
  }

  function createAttributeSetters(gl, program) {
    // Very similar to greggman's module:
    // webglfundamentals.org/docs/module-webgl-utils.html#.createAttributeSetters
    var attribSetters = {};
    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttribs; i++) {
      var attribInfo = gl.getActiveAttrib(program, i);
      if (!attribInfo) break;
      var index = gl.getAttribLocation(program, attribInfo.name);
      attribSetters[attribInfo.name] = createAttribSetter(gl, index);
    }
    return attribSetters;
  }

  function createAttribSetter(gl, index) {
    return function(b) {
      // Enable this attribute (shader attributes are disabled by default)
      gl.enableVertexAttribArray(index);
      // Bind the buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
      // Point the attribute in the program to this buffer,
      // and tell the program the byte layout in the buffer
      gl.vertexAttribPointer(
          index,                      // index of attribute in program
          b.numComponents || b.size,  // Number of elements to read per vertex
          b.type || gl.FLOAT,         // Type of each element
          b.normalize || false,       // Whether to normalize it
          b.stride || 0,              // Byte spacing between vertices
          b.offset || 0               // Byte # to start reading from
          );
    };
  }

  function setBuffersAndAttributes(gl, setters, buffers) {
    setAttributes(setters, buffers.attributes);
    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices.buffer);
    }
  }

  function setAttributes(setters, attribs) {
    Object.keys(attribs).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter( attribs[name] );
    });
  }

  function createUniformSetters$1(gl, program) {
    // Very similar to greggman's module:
    // webglfundamentals.org/docs/module-webgl-utils.html#.createUniformSetters

    // Track texture bindpoint index in case multiple textures are required
    var textureUnit = 0;

    const uniformSetters = {};
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (let i = 0; i < numUniforms; i++) {
      let uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) break;

      let { name, type, size } = uniformInfo;
      let loc = gl.getUniformLocation(program, name);

      // getActiveUniform adds a suffix to the names of arrays
      let isArray = (name.slice(-3) === "[0]");
      let key = (isArray)
        ? name.slice(0, -3)
        : name;

      uniformSetters[key] = createUniformSetter(loc, type, isArray, size);
    }

    return uniformSetters;

    // This function must be nested to access the textureUnit index
    function createUniformSetter(loc, type, isArray, size) {
      switch (type) {
        case gl.FLOAT:
          return (isArray)
            ? (v) => gl.uniform1fv(loc, v)
            : (v) => gl.uniform1f(loc, v);
        case gl.FLOAT_VEC2:
          return (v) => gl.uniform2fv(loc, v);
        case gl.FLOAT_VEC3:
          return (v) => gl.uniform3fv(loc, v);
        case gl.FLOAT_VEC4:
          return (v) => gl.uniform4fv(loc, v);
        case gl.INT:
          return (isArray)
            ? (v) => gl.uniform1iv(loc, v)
            : (v) => gl.uniform1i(loc, v);
        case gl.INT_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.INT_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.INT_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.BOOL:
          return (v) => gl.uniform1iv(loc, v);
        case gl.BOOL_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.BOOL_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.BOOL_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.FLOAT_MAT2:
          return (v) => gl.uniformMatrix2fv(loc, false, v);
        case gl.FLOAT_MAT3:
          return (v) => gl.uniformMatrix3fv(loc, false, v);
        case gl.FLOAT_MAT4:
          return (v) => gl.uniformMatrix4fv(loc, false, v);
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          var bindPoint = getBindPointForSamplerType$1(gl, type);
          if (isArray) {
            var units = Array.from(Array(size), () => textureUnit++);
            return function(textures) {
              gl.uniform1iv(loc, units);
              textures.forEach( function(texture, index) {
                gl.activeTexture(gl.TEXTURE0 + units[index]);
                gl.bindTexture(bindPoint, texture);
              });
            };
          } else {
            var unit = textureUnit++;
            return function(texture) {
              gl.uniform1i(loc, unit);
              gl.activeTexture(gl.TEXTURE0 + unit);
              gl.bindTexture(bindPoint, texture);
            };
          }
       default:  // we should never get here
          throw("unknown type: 0x" + type.toString(16));
      }
    }
  }

  function getBindPointForSamplerType$1(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;
    return undefined;
  }

  function setUniforms$1(setters, values) {
    Object.entries(values).forEach(([key, val]) => {
      var setter = setters[key];
      if (setter) setter(val);
    });
  }

  // Initialize a shader program
  function initShaderProgram(gl, vsSource, fsSource) {
    // NOTE: Load any WebGL extensions before calling this

    const vertexShader = loadShader$1(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader$1(gl, gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      throw Error('Unable to initialize the shader program: \n' +
          gl.getProgramInfoLog(shaderProgram) );
    }

    return {
      program: shaderProgram,
      attributeSetters: createAttributeSetters(gl, shaderProgram),
      uniformSetters: createUniformSetters$1(gl, shaderProgram),
    };
  }

  // create shader of a given type, upload source, compile it
  function loadShader$1(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw Error('An error occurred compiling the shaders: \n' +
          gl.getShaderInfoLog(shader) );
    }

    return shader;
  }

  function drawScene(gl, programInfo, bufferInfo, uniforms, viewport) {
    // Make a blank canvas that fills the displayed size from CSS
    prepCanvas(gl, viewport);

    // Tell WebGL to use our program when drawing
    gl.useProgram(programInfo.program);

    // Prepare shader attributes.
    setBuffersAndAttributes( gl, programInfo.attributeSetters, bufferInfo );
    // Set the shader uniforms
    setUniforms$1( programInfo.uniformSetters, uniforms );

    // Draw the scene
    gl.drawElements(gl.TRIANGLES, bufferInfo.indices.vertexCount,
        bufferInfo.indices.type, bufferInfo.indices.offset);

    // Turn off the scissor test for now  TODO: is this necessary?
    gl.disable(gl.SCISSOR_TEST);
  }

  function prepCanvas(gl, port) {
    // Set some parameters
    gl.clearColor(0.0, 0.0, 0.0, 0.0);  // Clear to transparent black
    gl.clearDepth(1.0);                 // Clear everything
    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

    // Tell WebGL how to convert from clip space to pixels
    if (port !== undefined) {
      gl.viewport(port.left, port.bottom, port.width, port.height);
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(port.left, port.bottom, port.width, port.height);
    } else {
      // Use the whole canvas
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }

    // Clear the canvas AND the depth buffer
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    return;
  }

  var vertexSrc = `attribute vec4 aVertexPosition;
uniform vec2 uMaxRay;

varying highp vec2 vRayParm;

void main(void) {
  vRayParm = uMaxRay * aVertexPosition.xy;
  gl_Position = aVertexPosition;
}
`;

  var invertSrc = `uniform float uLat0;
uniform float uCosLat0;
uniform float uSinLat0;
uniform float uTanLat0;

float latChange(float x, float y, float sinC, float cosC) {
  float xtan = x * uTanLat0;
  float curveTerm = 0.5 * y * (xtan * xtan - y * y / 3.0);

  return (max(sinC, abs(sinC * uTanLat0) ) < 0.1)
    ? sinC * (y - sinC * (0.5 * xtan * x + curveTerm * sinC))
    : asin(uSinLat0 * cosC + y * uCosLat0 * sinC) - uLat0;
}

vec2 xyToLonLat(vec2 xy, float sinC, float cosC) {
  vec2 pHat = normalize(xy);
  float dLon = atan(pHat.x * sinC,
      uCosLat0 * cosC - pHat.y * uSinLat0 * sinC);
  float dLat = latChange(pHat.x, pHat.y, sinC, cosC);
  return vec2(dLon, dLat);
}
`;

  var projectSrc = `const float ONEOVERTWOPI = 0.15915493667125702;

uniform float uExpY0;
uniform float uLatErr; // Difference of clipping to map limit

float smallTan(float x) {
  return (abs(x) < 0.1)
    ? x * (1.0 + x * x / 3.0)
    : tan(x);
}

float log1plusX(float x) {
  return (abs(x) < 0.15)
    ? x * (1.0 - x * (0.5 - x / 3.0 + x * x / 4.0))
    : log( 1.0 + max(x, -0.999) );
}

vec2 projMercator(vec2 dLonLat) {
  float tandlat = smallTan( 0.5 * (dLonLat[1] + uLatErr) );
  float p = tandlat * uExpY0;
  float q = tandlat / uExpY0;
  return vec2(dLonLat[0], log1plusX(q) - log1plusX(-p)) * ONEOVERTWOPI;
}
`;

  function glslInterp(strings, ...expressions) {
    return strings.reduce( (acc, val, i) => acc + expressions[i-1]() + val );
  }
  var texLookup = (args) => glslInterp`const int nLod = ${args.nLod};

uniform sampler2D uTextureSampler[nLod];
uniform vec2 uCamMapPos[nLod];
uniform vec2 uMapScales[nLod];

float dateline(float x1) {
  // Choose the correct texture coordinate in fragments crossing the
  // antimeridian of a cylindrical coordinate system
  // See http://vcg.isti.cnr.it/~tarini/no-seams/

  // Alternate coordinate: forced across the antimeridian
  float x2 = fract(x1 + 0.5) - 0.5;
  // Choose the coordinate with the smaller screen-space derivative
  return (fwidth(x1) < fwidth(x2) + 0.001) ? x1 : x2;
}

bool inside(vec2 pos) {
  // Check if the supplied texture coordinate falls inside [0,1] X [0,1]
  // We adjust the limits slightly to ensure we are 1 pixel away from the edges
  return (
      0.001 < pos.x && pos.x < 0.999 &&
      0.001 < pos.y && pos.y < 0.999 );
}

vec4 sampleLOD(sampler2D samplers[nLod], vec2 coords[nLod]) {
  return ${args.buildSelector}texture2D(samplers[0], coords[0]);
}

vec4 texLookup(vec2 dMerc) {
  vec2 texCoords[nLod];

  for (int i = 0; i < nLod; i++) {
    texCoords[i] = uCamMapPos[i] + uMapScales[i] * dMerc;
    texCoords[i].x = dateline(texCoords[i].x);
  }

  return sampleLOD(uTextureSampler, texCoords);
}
`;

  var dither2x2 = `float threshold(float val, float limit) {
  float decimal = fract(255.0 * val);
  float dithered = (decimal < limit)
    ? 0.0
    : 1.0;
  float adjustment = (dithered - decimal) / 255.0;
  return val + adjustment;
}

vec3 dither2x2(vec2 position, vec3 color) {
  // Based on https://github.com/hughsk/glsl-dither/blob/master/2x2.glsl
  int x = int( mod(position.x, 2.0) );
  int y = int( mod(position.y, 2.0) );
  int index = x + y * 2;

  float limit = 0.0;
  if (index == 0) limit = 0.25;
  if (index == 1) limit = 0.75;
  if (index == 2) limit = 1.00;
  if (index == 3) limit = 0.50;

  // Use limit to toggle color between adjacent 8-bit values
  return vec3(
      threshold(color.r, limit),
      threshold(color.g, limit),
      threshold(color.b, limit)
      );
}
`;

  var fragMain = `float diffSqrt(float x) {
  // Returns 1 - sqrt(1-x), with special handling for small x
  float halfx = 0.5 * x;
  return (x < 0.1)
    ? halfx * (1.0 + 0.5 * halfx * (1.0 + halfx))
    : 1.0 - sqrt(1.0 - x);
}

float horizonTaper(float gamma) {
  // sqrt(gamma) = tan(ray_angle) / tan(horizon)
  float horizonRatio = sqrt(gamma);
  float delta = 2.0 * fwidth(horizonRatio);
  return 1.0 - smoothstep(1.0 - delta, 1.0, horizonRatio);
}

varying vec2 vRayParm;
uniform float uHnorm;

void main(void) {
  // 0. Pre-compute some values
  float p = length(vRayParm); // Tangent of ray angle
  float p2 = p * p;
  float gamma = p2 * uHnorm * (2.0 + uHnorm);
  float sinC = (uHnorm + diffSqrt(gamma)) * p / (1.0 + p2);
  float cosC = sqrt(1.0 - sinC * sinC);

  // 1. Invert for longitude and latitude perturbations relative to camera
  vec2 dLonLat = xyToLonLat(vRayParm, sinC, cosC);

  // 2. Project to a change in the Mercator coordinates
  vec2 dMerc = projMercator(dLonLat);

  // 3. Lookup color from the appropriate texture
  vec4 texelColor = texLookup(dMerc);

  // Add cosine shading, dithering, and horizon tapering
  vec3 dithered = dither2x2(gl_FragCoord.xy, cosC * texelColor.rgb);
  gl_FragColor = vec4(dithered.rgb, texelColor.a) * horizonTaper(gamma);
}
`;

  const header = `
precision highp float;
precision highp sampler2D;

`;

  function buildShader(nLod) {
    // Input nLod is the number of 'levels of detail' supplied
    // in the set of multi-resolution maps
    nLod = Math.max(1, Math.floor(nLod));

    // Execute the 'tagged template literal' added to texLookup.js.glsl by
    // ../../build/glsl-plugin.js. This will substitute nLod-dependent code
    const args = { // Properties MUST match ./texLookup.js.glsl
      nLod: () => nLod,
      buildSelector: () => buildSelector(nLod),
    };
    const texLookupSrc = texLookup(args);

    // Combine the GLSL-snippets into one shader source
    const fragmentSrc = header + invertSrc + projectSrc + 
      texLookupSrc + dither2x2 + fragMain;

    return {
      vert: vertexSrc,
      frag: fragmentSrc,
    };
  }

  function buildSelector(n) {
    // In the texLookup code, add lines to check each of the supplied textures,
    // and sample the highest LOD that contains the current coordinate
    var selector = ``;
    while (--n) selector += `inside(coords[${n}])
    ? texture2D(samplers[${n}], coords[${n}])
    : `;
    return selector;
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat$2 = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function getWebMercatorFactors(camLatitude) {
    // Clip latitude to map limits
    var clipLat = Math.min(Math.max(-maxMercLat$2, camLatitude), maxMercLat$2);
    var latErr = camLatitude - clipLat;

    // camera exp(Y), for converting delta latitude to delta Y
    var expY = Math.tan( 0.25 * Math.PI + 0.5 * clipLat );

    return [expY, latErr];
  }

  function init$3(userParams) {
    const params = setParams$1(userParams);
    const gl = params.gl;

    // Initialize shader program
    const shaders = buildShader(params.nMaps);
    // TODO: use yawgl.initProgram
    const progInfo = initShaderProgram(gl, shaders.vert, shaders.frag);

    // Load data into GPU for shaders: attribute buffers, indices, textures
    // TODO: use the constructVao method returned by yawgl.initProgram
    const buffers = initQuadBuffers(gl);

    // Store links to uniform arrays
    const uniforms = {
      uMaxRay: new Float64Array(2),
      uTextureSampler: params.maps.map(tx => tx.sampler),
      uCamMapPos: new Float64Array(2 * params.nMaps),
      uMapScales: new Float64Array(2 * params.nMaps),
    };

    return {
      canvas: gl.canvas,
      draw,
      setPixelRatio: (ratio) => { params.getPixelRatio = () => ratio; },
      destroy: () => gl.canvas.remove(),
    };

    function draw(camPos, maxRayTan) {
      // Update uniforms related to camera position
      uniforms.uHnorm = camPos[2] / params.globeRadius;
      uniforms.uLat0 = camPos[1];
      uniforms.uCosLat0 = Math.cos(camPos[1]);
      uniforms.uSinLat0 = Math.sin(camPos[1]);
      uniforms.uTanLat0 = Math.tan(camPos[1]);
      [uniforms.uExpY0, uniforms.uLatErr] = getWebMercatorFactors(camPos[1]);

      uniforms.uMaxRay.set(maxRayTan);

      // Set uniforms and update textures for each map
      params.maps.forEach( (map, index) => {
        // Flip orientation of Y, from Canvas2D to WebGL orientation
        let tmp = [map.camPos[0], 1.0 - map.camPos[1]];
        uniforms.uCamMapPos.set(tmp, 2 * index);
        uniforms.uMapScales.set(map.scale, 2 * index);
      });

      // Draw the globe
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, params.flipY);

      var resized = resizeCanvasToDisplaySize(
        gl.canvas, params.getPixelRatio() );
      // TODO: use the setupDraw method returned by yawgl.initProgram
      drawScene(gl, progInfo, buffers, uniforms);
      return resized;
    }
  }

  const degrees = 180.0 / Math.PI;

  const radius = 6371;

  function main() {
    const canvas = document.getElementById("globe");
    const gl = getExtendedContext(canvas);

    initMap(gl)
      .then(map => setup$2(map, gl))
      .catch(console.log);
  }

  function setup$2(map, gl) {
    var requestID;
    const camPosition = new Float64Array(3);

    // Get links to lon/lat/alt inputs and display div
    const coordInput = document.getElementById("coordInput");

    const view = initView(gl.canvas, 25.0);

    const renderer = init$3({
      gl,
      globeRadius: radius,
      map: map.texture,
      flipY: false,
    });

    coordInput.addEventListener("input", getCoords, false);
    getCoords();

    function getCoords() {
      let coords = coordInput.elements;
      camPosition[0] = coords["lon"].value / degrees;
      camPosition[1] = coords["lat"].value / degrees;
      camPosition[2] = coords["alt"].value;

      // Start a rendering loop. Cancel running loops to avoid memory leaks
      cancelAnimationFrame(requestID);
      requestID = requestAnimationFrame(animate);
    }

    function animate(time) {
      let resized = view.changed();
      map.draw(camPosition, radius, view);
      renderer.draw(camPosition, view.maxRay, true);

      if (map.loaded() < 1.0) requestAnimationFrame(animate);
    }
  }

  exports.main = main;

  return exports;

}({}));
