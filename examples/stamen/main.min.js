var app = (function (exports) {
  'use strict';

  function getExtendedContext(canvas) {
    const haveCanvas = canvas instanceof Element;
    if (!haveCanvas || canvas.tagName.toLowerCase() !== "canvas") {
      throw Error("ERROR in yawgl.getExtendedContext: not a valid Canvas!");
    }
    const gl = canvas.getContext("webgl");

    // developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
    //   #Take_advantage_of_universally_supported_WebGL_1_extensions
    const universalExtensions = [
      "ANGLE_instanced_arrays",
      "EXT_blend_minmax",
      "OES_element_index_uint",
      "OES_standard_derivatives",
      "OES_vertex_array_object",
      "WEBGL_debug_renderer_info",
      "WEBGL_lose_context"
    ];
    universalExtensions.forEach(ext => getAndApplyExtension(gl, ext));

    // Modify the shaderSource method to add a preamble
    const SHADER_PREAMBLE = `
#extension GL_OES_standard_derivatives : enable
#line 1
`;
    const shaderSource = gl.shaderSource;
    gl.shaderSource = function(shader, source) {
      const modified = (source.indexOf("GL_OES_standard_derivatives") < 0)
        ? SHADER_PREAMBLE + source
        : source;
      shaderSource.call(gl, shader, modified);
    };

    return gl;
  }

  function getAndApplyExtension(gl, name) {
    // https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html
    const ext = gl.getExtension(name);
    if (!ext) return console.log("yawgl: extension " + name + " not supported!");

    const fnSuffix = name.split("_")[0];
    const enumSuffix = '_' + fnSuffix;

    for (const key in ext) {
      const value = ext[key];
      const isFunc = typeof value === 'function';
      const suffix = isFunc ? fnSuffix : enumSuffix;
      const glKey = (key.endsWith(suffix))
        ? key.substring(0, key.length - suffix.length)
        : key;
      if (gl[glKey] !== undefined) {
        if (!isFunc && gl[glKey] !== value) {
          console.warn("conflict:", name, gl[glKey], value, key);
        }
      } else if (isFunc) {
        gl[glKey] = (function(origFn) {
          return function() {
            return origFn.apply(ext, arguments);
          };
        })(value);
      } else {
        gl[glKey] = value;
      }
    }
  }

  function createUniformSetter(gl, program, info, textureUnit) {
    const { name, type, size } = info;
    const isArray = name.endsWith("[0]");
    const loc = gl.getUniformLocation(program, name);

    switch (type) {
      case gl.FLOAT:
        return (isArray)
          ? (v) => gl.uniform1fv(loc, v)
          : (v) => gl.uniform1f(loc, v);
      case gl.FLOAT_VEC2:
        return (v) => gl.uniform2fv(loc, v);
      case gl.FLOAT_VEC3:
        return (v) => gl.uniform3fv(loc, v);
      case gl.FLOAT_VEC4:
        return (v) => gl.uniform4fv(loc, v);
      case gl.INT:
        return (isArray)
          ? (v) => gl.uniform1iv(loc, v)
          : (v) => gl.uniform1i(loc, v);
      case gl.INT_VEC2:
        return (v) => gl.uniform2iv(loc, v);
      case gl.INT_VEC3:
        return (v) => gl.uniform3iv(loc, v);
      case gl.INT_VEC4:
        return (v) => gl.uniform4iv(loc, v);
      case gl.BOOL:
        return (v) => gl.uniform1iv(loc, v);
      case gl.BOOL_VEC2:
        return (v) => gl.uniform2iv(loc, v);
      case gl.BOOL_VEC3:
        return (v) => gl.uniform3iv(loc, v);
      case gl.BOOL_VEC4:
        return (v) => gl.uniform4iv(loc, v);
      case gl.FLOAT_MAT2:
        return (v) => gl.uniformMatrix2fv(loc, false, v);
      case gl.FLOAT_MAT3:
        return (v) => gl.uniformMatrix3fv(loc, false, v);
      case gl.FLOAT_MAT4:
        return (v) => gl.uniformMatrix4fv(loc, false, v);
      case gl.SAMPLER_2D:
        return getTextureSetter(gl.TEXTURE_2D);
      case gl.SAMPLER_CUBE:
        return getTextureSetter(gl.TEXTURE_CUBE_MAP);
      default:  // we should never get here
        throw("unknown type: 0x" + type.toString(16));
    }

    function getTextureSetter(bindPoint) {
      return (isArray)
        ? buildTextureArraySetter(bindPoint)
        : buildTextureSetter(bindPoint);
    }

    function buildTextureSetter(bindPoint) {
      return function(texture) {
        gl.uniform1i(loc, textureUnit);
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
        gl.bindTexture(bindPoint, texture);
      };
    }

    function buildTextureArraySetter(bindPoint) {
      const units = Array.from(Array(size), () => textureUnit++);
      return function(textures) {
        gl.uniform1iv(loc, units);
        textures.forEach((texture, i) => {
          gl.activeTexture(gl.TEXTURE0 + units[i]);
          gl.bindTexture(bindPoint, texture);
        });
      };
    }
  }

  function createUniformSetters(gl, program) {
    const typeSizes = {
      [gl.FLOAT]: 1,
      [gl.FLOAT_VEC2]: 2,
      [gl.FLOAT_VEC3]: 3,
      [gl.FLOAT_VEC4]: 4,
      [gl.INT]: 1,
      [gl.INT_VEC2]: 2,
      [gl.INT_VEC3]: 3,
      [gl.INT_VEC4]: 4,
      [gl.BOOL]: 1,
      [gl.BOOL_VEC2]: 2,
      [gl.BOOL_VEC3]: 3,
      [gl.BOOL_VEC4]: 4,
      [gl.FLOAT_MAT2]: 4,
      [gl.FLOAT_MAT3]: 9,
      [gl.FLOAT_MAT4]: 16,
      [gl.SAMPLER_2D]: 1,
      [gl.SAMPLER_CUBE]: 1,
    };

    // Collect info about all the uniforms used by the program
    const uniformInfo = Array
      .from({ length: gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS) })
      .map((v, i) => gl.getActiveUniform(program, i))
      .filter(info => info !== undefined);

    const textureTypes = [gl.SAMPLER_2D, gl.SAMPLER_CUBE];
    var textureUnit = 0;

    return uniformInfo.reduce((d, info) => {
      let { name, type, size } = info;
      let isArray = name.endsWith("[0]");
      let key = isArray ? name.slice(0, -3) : name;

      //let setter = createUniformSetter(gl, program, info, textureUnit);
      //d[key] = wrapSetter(setter, isArray, type, size);
      d[key] = createUniformSetter(gl, program, info, textureUnit);

      if (textureTypes.includes(type)) textureUnit += size;

      return d;
    }, {});
  }

  function initAttributes(gl, program) {
    // Construct a dictionary of the indices of each attribute used by program
    const attrIndices = Array
      .from({ length: gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES) })
      .map((v, i) => gl.getActiveAttrib(program, i))
      .reduce((d, { name }, index) => (d[name] = index, d), {});

    // Construct a dictionary of functions to set a constant value for a given
    // vertex attribute, when a per-vertex buffer is not needed
    const constantSetters = Object.entries(attrIndices).reduce((d, [name, i]) => {
      d[name] = function(v) {
        gl.disableVertexAttribArray(i);

        // For float attributes, the supplied value may be a Number
        if (v.length === undefined) return gl.vertexAttrib1f(i, v);

        if (![1, 2, 3, 4].includes(v.length)) return;
        const methodName = "vertexAttrib" + v.length + "fv";
        gl[methodName](i, v);
      };
      return d;
    }, {});

    function constructVao({ attributes, indices }) {
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      Object.entries(attributes).forEach(([name, a]) => {
        const index = attrIndices[name];
        if (index === undefined) return;

        gl.enableVertexAttribArray(index);
        gl.bindBuffer(gl.ARRAY_BUFFER, a.buffer);
        gl.vertexAttribPointer(
          index,                // index of attribute in program
          a.numComponents || a.size, // Number of elements to read per vertex
          a.type || gl.FLOAT,   // Type of each element
          a.normalize || false, // Whether to normalize it
          a.stride || 0,        // Byte spacing between vertices
          a.offset || 0         // Byte # to start reading from
        );
        gl.vertexAttribDivisor(index, a.divisor || 0);
      });

      if (indices) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices.buffer);

      gl.bindVertexArray(null);
      return vao;
    }

    return { constantSetters, constructVao };
  }

  function initProgram(gl, vertexSrc, fragmentSrc) {
    const program = gl.createProgram();
    gl.attachShader(program, loadShader(gl, gl.VERTEX_SHADER, vertexSrc));
    gl.attachShader(program, loadShader(gl, gl.FRAGMENT_SHADER, fragmentSrc));
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      fail("Unable to link the program", gl.getProgramInfoLog(program));
    }

    const { constantSetters, constructVao } = initAttributes(gl, program);
    const uniformSetters = createUniformSetters(gl, program);

    return {
      uniformSetters: Object.assign(uniformSetters, constantSetters),
      use: () => gl.useProgram(program),
      constructVao,
    };
  }

  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      let log = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      fail("An error occured compiling the shader", log);
    }

    return shader;
  }

  function fail(msg, log) {
    throw Error("yawgl.initProgram: " + msg + ":\n" + log);
  }

  function initAttributeMethods(gl) {
    return { createBuffer, initAttribute, initIndices, initQuad };

    function createBuffer(data, bindPoint = gl.ARRAY_BUFFER) {
      const buffer = gl.createBuffer();
      gl.bindBuffer(bindPoint, buffer);
      gl.bufferData(bindPoint, data, gl.STATIC_DRAW);
      return buffer;
    }

    function initAttribute(options) {
      // Set defaults for unsupplied values
      const {
        buffer = createBuffer(options.data),
        numComponents = 3,
        type = gl.FLOAT,
        normalize = false,
        stride = 0,
        offset = 0,
        divisor = 1,
      } = options;

      // Return attribute state object
      return { buffer, numComponents, type, normalize, stride, offset, divisor };
    }

    function initIndices(options) {
      const {
        buffer = createBuffer(options.data, gl.ELEMENT_ARRAY_BUFFER),
        type = gl.UNSIGNED_INT,
        offset = 0,
      } = options;

      return { buffer, type, offset };
    }

    function initQuad({ x0 = -1.0, y0 = -1.0, x1 = 1.0, y1 = 1.0 } = {}) {
      // Create a buffer with the position of the vertices within one instance
      const data = new Float32Array([
        x0, y0,  x1, y0,  x1, y1,
        x0, y0,  x1, y1,  x0, y1,
      ]);

      return initAttribute({ data, numComponents: 2, divisor: 0 });
    }
  }

  function initMipMapper(gl, target) {
    const isPowerOf2 = (v) => Math.log2(v) % 1 == 0;
    const setAnisotropy = setupAnisotropy(gl, target);

    return function({ mips = true, width, height }) {
      if (mips && isPowerOf2(width) && isPowerOf2(height)) {
        setAnisotropy();
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.generateMipmap(target);
      } else {
        // WebGL1 can't handle mipmapping for non-power-of-2 images
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      }
    };
  }

  function setupAnisotropy(gl, target) {
    const ext = (
      gl.getExtension('EXT_texture_filter_anisotropic') ||
      gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || 
      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
    );
    if (!ext) return () => undefined;

    const maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    const pname = ext.TEXTURE_MAX_ANISOTROPY_EXT;

    // BEWARE: this texParameterf call is slow on Intel integrated graphics.
    return () => gl.texParameterf(target, pname, maxAnisotropy);
  }

  function initTextureMethods(gl) {
    const target = gl.TEXTURE_2D;
    const level = 0; // Mipmap level for image uploads
    const type = gl.UNSIGNED_BYTE;
    const border = 0;
    const getMips = initMipMapper(gl, target);

    return { initTexture, updateMips, initFramebuffer };

    function initTexture(options) {
      const {
        format = gl.RGBA,
        image, // ImageData, HTMLImageElement, HTMLCanvasElement, ImageBitmap
        data = null,  // ArrayBufferView
        mips = true,
        wrapS = gl.CLAMP_TO_EDGE,
        wrapT = gl.CLAMP_TO_EDGE,
      } = options;

      // For Image input, get size from element. Otherwise it must be supplied
      const { 
        width = 1, 
        height = 1,
      } = (image) ? image : options;

      const texture = gl.createTexture();
      gl.bindTexture(target, texture);

      gl.texParameteri(target, gl.TEXTURE_WRAP_S, wrapS);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, wrapT);
      if (format !== gl.RGBA) gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

      if (image) {
        gl.texImage2D(target, level, format, format, type, image);
      } else {
        gl.texImage2D(target, level, format,
          width, height, border, format, type, data);
      }

      getMips({ mips, width, height });

      return texture;
    }

    function updateMips(texture) {
      gl.bindTexture(target, texture);
      gl.generateMipmap(target);
    }

    function initFramebuffer({ width, height }) {
      const texture = initTexture({ width, height });

      const buffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
        target, texture, level);

      gl.bindTexture(target, null);

      return {
        sampler: texture, // TODO: rename to texture?
        buffer,
        size: { width, height },
      };
    }
  }

  function initContext(gl) {
    // Input is an extended WebGL context, as created by yawgl.getExtendedContext
    const canvas = gl.canvas;
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    const api = { gl,
      initProgram: (vert, frag) => initProgram(gl, vert, frag),
      resizeCanvasToDisplaySize,
      bindFramebufferAndSetViewport,
      clear,
      clipRect,
      draw,
    };

    return Object.assign(api, initAttributeMethods(gl), initTextureMethods(gl));

    function resizeCanvasToDisplaySize(multiplier) {
      if (!multiplier || multiplier < 0) multiplier = 1;

      const width = Math.floor(canvas.clientWidth * multiplier);
      const height = Math.floor(canvas.clientHeight * multiplier);

      if (canvas.width === width && canvas.height === height) return false;

      canvas.width = width;
      canvas.height = height;
      return true;
    }

    function bindFramebufferAndSetViewport(options = {}) {
      const { buffer = null, size = gl.canvas } = options;
      let { width, height } = size;
      gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
      gl.viewport(0, 0, width, height);
    }

    function clear(color = [0.0, 0.0, 0.0, 0.0]) {
      gl.disable(gl.SCISSOR_TEST);
      gl.clearColor(...color);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }

    function clipRect(x, y, width, height) {
      gl.enable(gl.SCISSOR_TEST);
      let roundedArgs = [x, y, width, height].map(Math.round);
      gl.scissor(...roundedArgs);
    }

    function draw({ vao, indices, count = 6, instanceCount = 1 }) {
      const mode = gl.TRIANGLES;
      gl.bindVertexArray(vao);
      if (indices) {
        let { type, offset } = indices;
        gl.drawElementsInstanced(mode, count, type, offset, instanceCount);
      } else {
        gl.drawArraysInstanced(mode, 0, count, instanceCount);
      }
      gl.bindVertexArray(null);
    }
  }

  function initView(porthole, fieldOfView) {
    // The porthole is an HTML element acting as a window into a 3D world
    // fieldOfView is the vertical view angle range in degrees (floating point)

    // Compute values for transformation between the 3D world and the 2D porthole
    var portRect, width, height, aspect;
    var tanFOV = Math.tan(fieldOfView * Math.PI / 180.0 / 2.0);
    const maxRay = [];

    computeRayParams(); // Set initial values

    return {
      element: porthole, // Back-reference
      changed: computeRayParams,

      width: () => width,
      height: () => height,
      topEdge: () => maxRay[1],   // tanFOV
      rightEdge: () => maxRay[0], // aspect * tanFOV
      maxRay, // TODO: is it good to expose local state?
      getRayParams,
    };

    function computeRayParams() {
      // Compute porthole size
      portRect = porthole.getBoundingClientRect();
      let newWidth = portRect.right - portRect.left;
      let newHeight = portRect.bottom - portRect.top;

      // Exit if no change
      if (width === newWidth && height === newHeight) return false;

      // Update stored values
      width = newWidth;
      height = newHeight;
      aspect = width / height;
      maxRay[0] = aspect * tanFOV;
      maxRay[1] = tanFOV; // Probably no change, but it is exposed externally

      // Let the calling program know that the porthole changed
      return true;
    }

    // Convert a position on the screen into tangents of the angles
    // (relative to screen normal) of a ray shooting off into the 3D space
    function getRayParams(rayVec, clientX, clientY) {
      // NOTE strange behavior of getBoundingClientRect()
      // rect.left and .top are equal to the coordinates given by clientX/Y
      // when the mouse is at the left top pixel in the box.
      // rect.right and .bottom are NOT equal to clientX/Y at the bottom
      // right pixel -- they are one more than the clientX/Y values.
      // Thus the number of pixels in the box is given by 
      //    porthole.clientWidth = rect.right - rect.left  (NO +1 !!)
      var x = clientX - portRect.left;
      var y = portRect.bottom - clientY - 1; // Flip sign to make +y upward

      // Normalized distances from center of box. We normalize by pixel DISTANCE
      // rather than pixel count, to ensure we get -1 and +1 at the ends.
      // (Confirm by considering the 2x2 case)
      var xratio = 2 * x / (width - 1) - 1;
      var yratio = 2 * y / (height - 1) -1;

      rayVec[0] = xratio * maxRay[0];
      rayVec[1] = yratio * maxRay[1];
      //rayVec[2] = -1.0;
      //rayVec[3] = 0.0;
      return;
    }
  }

  function initCache(size, tileFactory) {
    // Initialize the tiles object
    const tiles = {};
    const getID = tileFactory.getID || ( zxy => zxy.join("/") );

    // Return methods for accessing and updating the tiles
    return {
      retrieve: (zxy) => getTileOrParent(zxy, 0, 0, size),
      process,
      prune,
      trim,
      getPriority: (id) => (tiles[id]) ? tiles[id].priority : undefined,
    };

    function getTileOrParent(
        zxy,        // Coordinates of the requested tile (could be more than 3D)
        sx, sy, sw  // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object, add cropping info
      let id = getID(zxy);
      let tile = tiles[id];
      let tilebox = { tile, sx, sy, sw };

      // If the tile exists and is ready, return it (along with the wrapped info)
      if (tile && tile.rendered) return tilebox;

      // Looks like the tile wasn't ready. Try using the parent tile
      if (zxy[0] > 0 && sw > 1) { // Don't look too far back
        let [z, x, y] = zxy;

        // Get coordinates of the parent tile
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        // Copy any additional coordinates beyond the first 3
        let pzxy = [pz, px, py, ...zxy.slice(3)];

        // Compute cropping parameters for the parent
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        // Get the parent tile. Recursive!
        tilebox = getTileOrParent(pzxy, psx, psy, psw);
      }

      // If the requested tile didn't exist, we need to order it from the factory
      // NOTE: orders are placed AFTER the recursive call for the parent tile,
      // so missing parents will be ordered first
      if (!tile) {
        // For backwards compatibility, assume tileFactory.create still takes
        // a list of coordinates as arguments
        let newTile = tileFactory.create(...zxy);
        if (newTile) tiles[id] = newTile;
      } else if (tileFactory.redraw) {
        // Tile exists but isn't ready. Make sure it is rendering
        tileFactory.redraw(tile);
      }

      return (tilebox && tilebox.tile && tilebox.tile.rendered)
        ? tilebox
        : undefined;
    }

    function process(func) {
      Object.values(tiles).forEach( tile => func(tile) );
    }

    function prune(metric, threshold) {
      // Update tile priorities using the supplied metric. ASSUMES 3 args!
      process(tile => { tile.priority = metric(tile.z, tile.x, tile.y); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function trim(metric, threshold) {
      // Update tile priorities using the supplied metric
      process(tile => { tile.priority = metric(tile); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function drop(threshold) {
      var numTiles = 0;
      for (let id in tiles) {
        if (tiles[id].priority > threshold) {
          tiles[id].cancel();
          delete tiles[id];
        } else {
          numTiles ++;
        }
      }
      return numTiles;
    }
  }

  function initRasterCache(tileSize, getURL) {
    return initCache( tileSize, initRasterFactory(getURL) );
  }

  // Basic tile factory for raster data
  function initRasterFactory(getURL) {
    // Input getURL returns a tile URL for given indices z, x, y, t  (t optional)

    return { create };

    function create(z,x, y, t) {
      const tileHref = getURL(z, x, y, t);
      const img = loadImage(tileHref, checkData);

      const tile = { 
        z, x, y, t,  // t may be undefined, for 3D tile services
        img,
        cancel,
        canceled: false,
        rendered: false,
      };

      function checkData(err) {
        if (tile.canceled) return;
        if (err) return console.log(err);
        tile.rendered = true;
      }

      function cancel() {
        img.src = "";
        tile.canceled = true;
      }

      return tile;
    }
  }

  function loadImage(href, callback) {
    const errMsg = "ERROR in loadImage for href " + href;

    const img = new Image();
    img.onerror = () => callback(errMsg);
    img.onload = checkImg;
    img.crossOrigin = "anonymous";
    img.src = href;

    return img;

    function checkImg() {
      return (img.complete && img.naturalWidth !== 0)
        ? callback(null)
        : callback(errMsg);
    }
  }

  function setParams(userParams) {
    const params = {};

    params.getTile = userParams.getTile;

    params.tileSize = userParams.tileSize || 512;

    // Get canvas context, and set width/height parameters
    if (userParams.context) {
      params.context = userParams.context;
      params.width = userParams.width || params.context.canvas.width;
      params.height = userParams.height || params.context.canvas.height;
    } else {
      params.context = document.createElement("canvas").getContext("2d");
      params.width = userParams.width || 1024;
      params.height = userParams.height || 1024;
    }

    // Compute number of tiles in each direction.
    params.nx = Math.floor(params.width / params.tileSize);
    params.ny = Math.floor(params.height / params.tileSize);
    if (params.nx * params.tileSize !== params.width ||
        params.ny * params.tileSize !== params.height ) {
      console.log("width, height, tileSize = " +
          params.width + ", " + params.height + ", " + params.tileSize);
      return console.log("ERROR: width, height are not multiples of tileSize!!");
    }
    console.log("map size: " + params.width + "x" + params.height);

    // Define a min zoom (if not supplied), such that there are always enough
    // tiles to cover the grid without repeating
    params.minZoom = (userParams.minZoom === undefined)
      ? Math.floor( Math.min(Math.log2(params.nx), Math.log2(params.ny)) )
      : Math.max(0, Math.floor(userParams.minZoom));
    // Make sure any supplied max zoom is an integer larger than minZoom
    params.maxZoom = (userParams.maxZoom === undefined)
      ? 22
      : Math.max(params.minZoom, Math.floor(userParams.maxZoom));
    // Make sure initial zoom is an integer within range
    params.zoom = (userParams.zoom === undefined)
      ? params.minZoom
      : Math.floor(userParams.zoom);
    params.zoom = Math.min(Math.max(params.minZoom, params.zoom), params.maxZoom);

    // Set the initial center of the map
    params.center = userParams.center || [0.5, 0.5], // X, Y in map coordinates
    params.center[0] = Math.min(Math.max(0.0, params.center[0]), 1.0);
    params.center[1] = Math.min(Math.max(0.0, params.center[1]), 1.0);

    return params;
  }

  function initBoundingBox(params, setCenterZoom) {

    return function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of X/Y coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (numTiles - 1) / 2 ** zoom > boxSize in both X and Y
      var zoomX = Math.log2( (params.nx - 1) / boxWidth );
      var zoomY = Math.log2( (params.ny - 1) / boxHeight );

      // Compute the coordinates of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0);
      if (centerX > 1) centerX -= 1;
      var centerY = 0.5 * (p1[1] + p2[1]);

      return setCenterZoom( [centerX, centerY], Math.min(zoomX, zoomY) );
    }
  }

  function initTileCoords( params ) {
    // TODO: verify code for non-Mercator projections. Assumes x is periodic

    var zoom, nTiles, xTile0, yTile0;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    // Set initial values
    setCenterZoom(params.center, params.zoom);

    return {
      // Methods to report info about current map state
      getScale: (i) => scale[i],
      getZXY,

      // Methods to compute positions within current map
      toLocal,
      xyToMapPixels,

      // Methods to update map state
      setCenterZoom,
      fitBoundingBox: initBoundingBox(params, setCenterZoom),
      move,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
    }

    function toLocal(local, global) {
      // TODO: wrapping is problematic
      local[0] = wrap(global[0] - origin[0], 1.0) * scale[0];
      local[1] = (global[1] - origin[1]) * scale[1];
    }

    function xyToMapPixels(local, global) {
      toLocal(local, global);
      local[0] *= params.width;
      local[1] *= params.height;
    }

    function setCenterZoom(center, zNew) {
      // 1. Make sure the supplied zoom is within range and an integer
      zNew = Math.min(Math.max(params.minZoom, zNew), params.maxZoom);
      zNew = Math.floor(zNew); // TODO: should this be Math.round() ?
      var nTnew = 2 ** zNew; // Number of tiles at this zoom level

      // 2. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      var x0new = Math.round(center[0] * nTnew - params.nx / 2.0);
      x0new = wrap(x0new, nTnew); // in case we crossed the antimeridian

      var y0new = Math.round(center[1] * nTnew - params.ny / 2.0);
      y0new = Math.min(Math.max(0, y0new), nTnew - params.ny); // Don't cross pole

      // 3. Return a flag indicating whether map parameters were updated
      return updateTransform(zNew, x0new, y0new);
    }

    function move(dz, dx, dy) {
      var dzi = Math.round(dz);
      var dxi = Math.round(dx);
      var dyi = Math.round(dy);

      // Panning first
      var x0new = wrap(xTile0 + dxi, nTiles);
      var y0new = wrap(yTile0 + dyi, nTiles);

      var zNew = zoom;
      while (dzi > 0 && zNew < params.maxZoom) {  // Zoom in
        zNew++;
        x0new = Math.floor(2 * x0new + params.nx / 2.0);
        y0new = Math.floor(2 * y0new + params.ny / 2.0);
        dzi--;
      }
      while (dzi < 0 && zNew > params.minZoom) {  // Zoom out
        zNew--;
        x0new = wrap( Math.ceil( (x0new - params.nx / 2.0) / 2 ), 2 ** zNew );
        y0new = wrap( Math.ceil( (y0new - params.ny / 2.0) / 2 ), 2 ** zNew );
        dzi++;
      }

      return updateTransform(zNew, x0new, y0new);
    }

    function updateTransform(zNew, x0new, y0new) {
      if (zNew === zoom && x0new === xTile0 && y0new === yTile0) return false;

      zoom = zNew;
      xTile0 = x0new;
      yTile0 = y0new;

      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / params.nx; // Problematic if < 1 ?
      scale[1] = nTiles / params.ny;

      return true;
    }
  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initRenderer(params) {
    const context = params.context;
    const size = params.tileSize;

    // Resize drawingbuffer to fit the specified number of tiles
    context.canvas.width = params.width;
    context.canvas.height = params.height;

    return {
      draw,
      clear,
    };

    function clear() {
      return context.clearRect(0, 0, params.width, params.height);
    }

    function draw(tilebox, ix, iy) {
      context.drawImage(
          tilebox.tile.img,  // Image to read, and paint to the canvas
          tilebox.sx,        // First x-pixel in tile to read
          tilebox.sy,        // First y-pixel in tile to read
          tilebox.sw,        // Number of pixels to read in x
          tilebox.sw,        // Number of pixels to read in y
          ix * size,         // First x-pixel in canvas to paint
          iy * size,         // First y-pixel in canvas to paint
          size,              // Number of pixels to paint in x
          size               // Number of pixels to paint in y
          );
      return;
    }
  }

  function initGrid(params, coords, renderer) {
    const boxes = Array.from(Array(params.ny), () => []);

    const oneTileComplete = 1. / params.nx / params.ny;
    var complete = 0.0;

    return {
      loaded: () => complete,
      getBox: (ix, iy) => (boxes[iy]) ? boxes[iy][ix] : undefined,
      drawTiles,
      reset,
    };

    function drawTiles() {
      var updated = false;
      if (complete === 1.0) return updated; // Map is complete, no change!
      const zxy = [];

      for (let iy = 0; iy < params.ny; iy++) {
        var row = boxes[iy];
        for (let ix = 0; ix < params.nx; ix++) {
          coords.getZXY(zxy, ix, iy);
          var currentZ = (row[ix]) 
            ? row[ix].tile.z
            : undefined;
          if (currentZ === zxy[0]) continue; // This tile already done

          var newbox = params.getTile( zxy );
          if (!newbox) continue; // No image available for this tile
          if (newbox.tile.z === currentZ) continue; // Tile already written

          row[ix] = newbox;
          renderer.draw(newbox, ix, iy);
          updated = true;

          if (newbox.tile.z === zxy[0]) complete += oneTileComplete;
        }
      }
      return updated;
    }

    function reset() {
      boxes.forEach(row => { row.length = 0; });
      complete = 0.0;
    }
  }

  function initTileMetric(params, getZXY) {
    const zxy = [];

    return function(tile) {
      // Get distances of the tile from the current map
      let dist = getDiffs(tile);
      
      // Use the largest horizontal distance, and adjust for zoom difference
      return Math.max(dist.dx, dist.dy) - 1.0 + 1.0 / 2 ** dist.dz;
    }

    function getDiffs(tile) {
      // Store coordinates of the corners of the map
      getZXY(zxy, 0, 0);
      let mb = {
        x1: zxy[1],
        x2: zxy[1] + params.nx + 1, // Note: may extend across antimeridian!
        y1: zxy[2],
        y2: zxy[2] + params.ny + 1,
      };

      // Store tile corners. Convert x, y to equivalent values at MAP zoom level
      let dz = zxy[0] - tile.z;
      let zoomFac = 2 ** dz;
      let tb = {
        x1: tile.x * zoomFac,
        x2: (tile.x + 1) * zoomFac,
        y1: tile.y * zoomFac,
        y2: (tile.y + 1) * zoomFac,
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      let nTiles = 2 ** zxy[0];
      let dx = Math.min( // Be careful with the antimeridian
        // Test for non-intersection with tile in raw position
        Math.max(mb.x1 - tb.x2, tb.x1 - mb.x2),
        // Re-test with tile shifted across antimeridian
        Math.max(mb.x1 - (tb.x2 + nTiles), tb.x1 + nTiles - mb.x2)
      );
      let dy = Math.max(mb.y1 - tb.y2, tb.y1 - mb.y2);

      return { dz, dx, dy };
    }
  }

  function init(userParams) {
    const params = setParams(userParams);
    if (!params) return;

    const coords = initTileCoords(params);
    const renderer = initRenderer(params);
    const grid = initGrid(params, coords, renderer);

    return {
      canvas: params.context.canvas,

      // Report status or data
      loaded: grid.loaded,
      getTilePos,
      // Methods to clear or update the canvas
      reset: grid.reset,
      clear,
      drawTiles: grid.drawTiles,

      // Coordinate methods to set the position and zoom of the map
      move:       (dz, dx, dy) => { if (coords.move(dz, dx, dy))       clear(); },
      fitBoundingBox: (p1, p2) => { if (coords.fitBoundingBox(p1, p2)) clear(); },
      setCenterZoom:    (c, z) => { if (coords.setCenterZoom(c, z))    clear(); },

      // Methods to convert coordinates, or report conversion parameters
      toLocal:       coords.toLocal,
      xyToMapPixels: coords.xyToMapPixels,
      getScale:      coords.getScale,

      // Metric to evaluate distance of a tile from the current grid
      tileDistance: initTileMetric(params, coords.getZXY),
    };

    function getTilePos(mapXY) {
      // Get indices to the tile box
      let fx = mapXY[0] / params.tileSize;
      let fy = mapXY[1] / params.tileSize;
      let ix = Math.floor(fx);
      let iy = Math.floor(fy);

      // Get the tile box itself
      let box = grid.getBox(ix, iy);
      if (!box) return;

      // Compute position and scaling within the tile
      let x = (fx - ix) * box.sw + box.sx;
      let y = (fy - iy) * box.sw + box.sy;
      let frac = box.sw / params.tileSize; // Fraction of the tile being used

      // Return the tile along with the projected position and scaling info
      return { x, y, frac, tile: box.tile };
    }

    function clear() { // TODO: Do we ever need grid.reset without clear?
      grid.reset();
      renderer.clear();
    }
  }

  function initClipMaps(mapParams, nLod) {
    // Create an array of maps, to be maintained at different resolutions
    // or "levels of detail" (LOD)
    const frames = Array.from(Array(nLod), () => init(mapParams));

    // Isolate the canvas data for return, and add texture coordinate info
    const textures = frames.map(frame => {
      return {
        canvas: frame.canvas,
        camPos: new Float64Array(2), // Camera position within canvas
        scale: new Float64Array(2),  // Scale of canvas relative to world map
        changed: true, // Flags whether the canvas has changed since last check
      };
    });

    // Return methods to query and update the array as one map
    return {
      textures,
      loaded: () => frames.reduce((sum, f) => sum + f.loaded() / nLod, 0),
      getTilePos,

      reset: () => frames.forEach(f => f.reset()),
      drawTiles,

      setCenterZoom,
      tileDistance: (tile) => Math.min(...frames.map(f => f.tileDistance(tile))),
    };

    function getTilePos(globalXY) {
      let tilePos, mapXY = [];

      // Get the highest resolution tile possible:
      //  start from last level, drop down to lower zooms as needed
      let level = nLod;
      while(level > 0 && !tilePos) {
        level--;
        frames[level].xyToMapPixels(mapXY, globalXY);
        tilePos = frames[level].getTilePos(mapXY);
      }
      return tilePos;
    }

    function drawTiles() {
      frames.forEach((frame, i) => { textures[i].changed = frame.drawTiles(); });
    }

    function setCenterZoom(center, zoom) {
      frames.forEach( (frame, index) => {
        // Set increasing zoom levels, up to last map with z = zoom
        let z = zoom - nLod + index + 1;
        frame.setCenterZoom(center, z);

        // Update texture coordinate transform parameters
        let texture = textures[index];
        frame.toLocal(texture.camPos, center);
        texture.scale[0] = frame.getScale(0);
        texture.scale[1] = frame.getScale(1);
      });
    }
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;
  const clipLat = (lat) => Math.min(Math.max(-maxMercLat, lat), maxMercLat);

  function scale(geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface.
    // Return value scales a (differential) distance along the plane tangent to
    // the sphere at position <geodetic> to a distance in map coordinates.
    // NOTE: ASSUMES a sphere of radius 1! Input distances should be
    //  pre-normalized by the appropriate radius
    return 1 / (2 * Math.PI * Math.cos( clipLat(geodetic[1]) ));
  }

  function lonLatToXY(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX( geodetic[0] );
    projected[1] = latToY( geodetic[1] );
    return;
  }

  function lonToX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
    var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
    Math.log( Math.tan(Math.PI / 4.0 + clipLat(lat) / 2.0) );
    // Clip range to [0,1], since y does not wrap around
    return Math.min(Math.max(0.0, y), 1.0);
  }

  function initMaps(mapParams, context) {
    // Wrapper for maps. Handles projection of spherical coordinates
    const xy = new Float64Array(2);
    const tileSize = mapParams.tileSize;

    const cache = initRasterCache(tileSize, tileURL);
    var numCachedTiles = 0;

    // Initialize array of 2D map grids
    mapParams.getTile = cache.retrieve;
    const maps = initClipMaps(mapParams, 2);

    // Add WebGL texture objects
    const textures = maps.textures.map(tx => {
      let { width, height } = tx.canvas;
      tx.sampler = context.initTexture({ width, height });
      return tx;
    });

    return {
      textures,
      loaded: maps.loaded,

      setPosition,
      draw,
    };

    function setPosition(camPos, radius, view) {
      // Get map zoom
      let dMap = camPos[2] / radius *        // Normalize to radius = 1
        view.topEdge() * 2 / view.height() * // ray tangent per pixel
        scale(camPos);            // Scale assumes sphere radius = 1
      let zoom = Math.round( -Math.log2(tileSize * dMap) );

      lonLatToXY(xy, camPos);
      maps.setCenterZoom(xy, zoom);
    }

    function draw() {
      maps.drawTiles();
      textures.forEach(tx => {
        let { width, height } = tx.canvas;
        tx.sampler = context.initTexture({ image: tx.canvas, width, height });
      });
      numCachedTiles = cache.trim(maps.tileDistance, 1.5);
    }
  }

  function tileURL(z, x, y) {
    const endpoint = "http://tile.stamen.com/toner-lite/{z}/{x}/{y}.png";
    return endpoint.replace(/{z}/, z).replace(/{x}/, x).replace(/{y}/, y);
  }

  function setParams$1(userParams) {
    const {
      context,
      pixelRatio,
      globeRadius = 6371,
      map,
      flipY = false,
    } = userParams;

    const getPixelRatio = (pixelRatio)
      ? () => userParams.pixelRatio
      : () => window.devicePixelRatio;
    // NOTE: getPixelRatio() returns the result of an object getter,
    //       NOT the property value at the time of getPixelRatio definition
    //  Thus, getPixelRatio will mirror any changes in the parent object

    const maps = Array.isArray(map)
      ? map
      : [map];

    if (!context || !(context.gl instanceof WebGLRenderingContext)) {
      throw("satellite-view: no valid WebGLRenderingContext!");
    }

    return { context, getPixelRatio, globeRadius, maps, flipY };
  }

  var vertexSrc = `attribute vec4 aVertexPosition;
uniform vec2 uMaxRay;

varying highp vec2 vRayParm;

void main(void) {
  vRayParm = uMaxRay * aVertexPosition.xy;
  gl_Position = aVertexPosition;
}
`;

  var invertSrc = `uniform float uLat0;
uniform float uCosLat0;
uniform float uSinLat0;
uniform float uTanLat0;

float latChange(float x, float y, float sinC, float cosC) {
  float xtan = x * uTanLat0;
  float curveTerm = 0.5 * y * (xtan * xtan - y * y / 3.0);

  return (max(sinC, abs(sinC * uTanLat0) ) < 0.1)
    ? sinC * (y - sinC * (0.5 * xtan * x + curveTerm * sinC))
    : asin(uSinLat0 * cosC + y * uCosLat0 * sinC) - uLat0;
}

vec2 xyToLonLat(vec2 xy, float sinC, float cosC) {
  vec2 pHat = normalize(xy);
  float dLon = atan(pHat.x * sinC,
      uCosLat0 * cosC - pHat.y * uSinLat0 * sinC);
  float dLat = latChange(pHat.x, pHat.y, sinC, cosC);
  return vec2(dLon, dLat);
}
`;

  var projectSrc = `const float ONEOVERTWOPI = 0.15915493667125702;

uniform float uExpY0;
uniform float uLatErr; // Difference of clipping to map limit

float smallTan(float x) {
  return (abs(x) < 0.1)
    ? x * (1.0 + x * x / 3.0)
    : tan(x);
}

float log1plusX(float x) {
  return (abs(x) < 0.15)
    ? x * (1.0 - x * (0.5 - x / 3.0 + x * x / 4.0))
    : log( 1.0 + max(x, -0.999) );
}

vec2 projMercator(vec2 dLonLat) {
  float tandlat = smallTan( 0.5 * (dLonLat[1] + uLatErr) );
  float p = tandlat * uExpY0;
  float q = tandlat / uExpY0;
  return vec2(dLonLat[0], log1plusX(q) - log1plusX(-p)) * ONEOVERTWOPI;
}
`;

  function glslInterp(strings, ...expressions) {
    return strings.reduce( (acc, val, i) => acc + expressions[i-1]() + val );
  }
  var texLookup = (args) => glslInterp`const int nLod = ${args.nLod};

uniform sampler2D uTextureSampler[nLod];
uniform vec2 uCamMapPos[nLod];
uniform vec2 uMapScales[nLod];

float dateline(float x1) {
  // Choose the correct texture coordinate in fragments crossing the
  // antimeridian of a cylindrical coordinate system
  // See http://vcg.isti.cnr.it/~tarini/no-seams/

  // Alternate coordinate: forced across the antimeridian
  float x2 = fract(x1 + 0.5) - 0.5;
  // Choose the coordinate with the smaller screen-space derivative
  return (fwidth(x1) < fwidth(x2) + 0.001) ? x1 : x2;
}

bool inside(vec2 pos) {
  // Check if the supplied texture coordinate falls inside [0,1] X [0,1]
  // We adjust the limits slightly to ensure we are 1 pixel away from the edges
  return (
      0.001 < pos.x && pos.x < 0.999 &&
      0.001 < pos.y && pos.y < 0.999 );
}

vec4 sampleLOD(sampler2D samplers[nLod], vec2 coords[nLod]) {
  return ${args.buildSelector}texture2D(samplers[0], coords[0]);
}

vec4 texLookup(vec2 dMerc) {
  vec2 texCoords[nLod];

  for (int i = 0; i < nLod; i++) {
    texCoords[i] = uCamMapPos[i] + uMapScales[i] * dMerc;
    texCoords[i].x = dateline(texCoords[i].x);
  }

  return sampleLOD(uTextureSampler, texCoords);
}
`;

  var dither2x2 = `float threshold(float val, float limit) {
  float decimal = fract(255.0 * val);
  float dithered = (decimal < limit)
    ? 0.0
    : 1.0;
  float adjustment = (dithered - decimal) / 255.0;
  return val + adjustment;
}

vec3 dither2x2(vec2 position, vec3 color) {
  // Based on https://github.com/hughsk/glsl-dither/blob/master/2x2.glsl
  int x = int( mod(position.x, 2.0) );
  int y = int( mod(position.y, 2.0) );
  int index = x + y * 2;

  float limit = 0.0;
  if (index == 0) limit = 0.25;
  if (index == 1) limit = 0.75;
  if (index == 2) limit = 1.00;
  if (index == 3) limit = 0.50;

  // Use limit to toggle color between adjacent 8-bit values
  return vec3(
      threshold(color.r, limit),
      threshold(color.g, limit),
      threshold(color.b, limit)
      );
}
`;

  var fragMain = `float diffSqrt(float x) {
  // Returns 1 - sqrt(1-x), with special handling for small x
  float halfx = 0.5 * x;
  return (x < 0.1)
    ? halfx * (1.0 + 0.5 * halfx * (1.0 + halfx))
    : 1.0 - sqrt(1.0 - x);
}

float horizonTaper(float gamma) {
  // sqrt(gamma) = tan(ray_angle) / tan(horizon)
  float horizonRatio = sqrt(gamma);
  float delta = 2.0 * fwidth(horizonRatio);
  return 1.0 - smoothstep(1.0 - delta, 1.0, horizonRatio);
}

varying vec2 vRayParm;
uniform float uHnorm;

void main(void) {
  // 0. Pre-compute some values
  float p = length(vRayParm); // Tangent of ray angle
  float p2 = p * p;
  float gamma = p2 * uHnorm * (2.0 + uHnorm);
  float sinC = (uHnorm + diffSqrt(gamma)) * p / (1.0 + p2);
  float cosC = sqrt(1.0 - sinC * sinC);

  // 1. Invert for longitude and latitude perturbations relative to camera
  vec2 dLonLat = xyToLonLat(vRayParm, sinC, cosC);

  // 2. Project to a change in the Mercator coordinates
  vec2 dMerc = projMercator(dLonLat);

  // 3. Lookup color from the appropriate texture
  vec4 texelColor = texLookup(dMerc);

  // Add cosine shading, dithering, and horizon tapering
  vec3 dithered = dither2x2(gl_FragCoord.xy, cosC * texelColor.rgb);
  gl_FragColor = vec4(dithered.rgb, texelColor.a) * horizonTaper(gamma);
}
`;

  const header = `
precision highp float;
precision highp sampler2D;

`;

  function buildShader(nLod) {
    // Input nLod is the number of 'levels of detail' supplied
    // in the set of multi-resolution maps
    nLod = Math.max(1, Math.floor(nLod));

    // Execute the 'tagged template literal' added to texLookup.js.glsl by
    // ../../build/glsl-plugin.js. This will substitute nLod-dependent code
    const args = { // Properties MUST match ./texLookup.js.glsl
      nLod: () => nLod,
      buildSelector: () => buildSelector(nLod),
    };
    const texLookupSrc = texLookup(args);

    // Combine the GLSL-snippets into one shader source
    const fragmentSrc = header + invertSrc + projectSrc + 
      texLookupSrc + dither2x2 + fragMain;

    return {
      vert: vertexSrc,
      frag: fragmentSrc,
    };
  }

  function buildSelector(n) {
    // In the texLookup code, add lines to check each of the supplied textures,
    // and sample the highest LOD that contains the current coordinate
    var selector = ``;
    while (--n) selector += `inside(coords[${n}])
    ? texture2D(samplers[${n}], coords[${n}])
    : `;
    return selector;
  }

  const maxMercLat$1 = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function init$1(userParams) {
    const params = setParams$1(userParams);
    const { context, maps, globeRadius } = params;

    // Initialize shader program
    const shaders = buildShader(maps.length);
    const program = context.initProgram(shaders.vert, shaders.frag);
    const { uniformSetters: setters, constructVao } = program;

    // Initialize VAO
    const aVertexPosition = context.initQuad();
    const vao = constructVao({ attributes: { aVertexPosition } });

    return {
      canvas: context.gl.canvas,
      draw,
      setPixelRatio: (ratio) => { params.getPixelRatio = () => ratio; },
      destroy: () => context.gl.canvas.remove(),
    };

    function draw(camPos, maxRayTan) {
      program.use();

      // Set uniforms related to camera position
      const lat = camPos[1];
      setters.uLat0(lat);
      setters.uCosLat0(Math.cos(lat));
      setters.uSinLat0(Math.sin(lat));
      setters.uTanLat0(Math.tan(lat));

      const clipLat = Math.min(Math.max(-maxMercLat$1, lat), maxMercLat$1);
      setters.uLatErr(lat - clipLat);
      setters.uExpY0(Math.tan(Math.PI / 4 + clipLat / 2));

      setters.uHnorm(camPos[2] / globeRadius);
      setters.uMaxRay(maxRayTan);

      setters.uCamMapPos(maps.flatMap(m => [m.camPos[0], 1.0 - m.camPos[1]]));
      setters.uMapScales(maps.flatMap(m => Array.from(m.scale)));
      setters.uTextureSampler(maps.map(m => m.sampler));

      // Draw the globe
      const resized = context.resizeCanvasToDisplaySize(params.getPixelRatio());

      context.bindFramebufferAndSetViewport();

      context.gl.pixelStorei(context.gl.UNPACK_FLIP_Y_WEBGL, params.flipY);

      context.clear();
      context.draw({ vao });

      return resized;
    }
  }

  const degrees = 180.0 / Math.PI;

  const mapParams = {
    tileSize: 256,
    maxZoom: 23,
    width: 1024,
    height: 1024,
  };
  const radius = 6371;

  function main() {
    var maps, requestID;
    const camPosition = new Float64Array(3);

    // Get links to lon/lat/alt inputs and display div
    const coordInput = document.getElementById("coordInput");

    const canvas = document.getElementById("globe");
    const view = initView(canvas, 25.0);
    const gl = getExtendedContext(canvas);
    const context = initContext(gl);

    // Setup coordinates interaction
    maps = initMaps(mapParams, context);

    const renderer = init$1({
      context, 
      globeRadius: radius,
      map: maps.textures,
      flipY: true,
    });

    coordInput.addEventListener("input", getCoords, false);
    getCoords();

    function getCoords() {
      let coords = coordInput.elements;
      camPosition[0] = coords["lon"].value / degrees;
      camPosition[1] = coords["lat"].value / degrees;
      camPosition[2] = coords["alt"].value;

      // Start a rendering loop. Cancel running loops to avoid memory leaks
      cancelAnimationFrame(requestID);
      requestID = requestAnimationFrame(animate);
    }

    function animate(time) {
      let resized = view.changed();
      maps.setPosition(camPosition, radius, view);
      maps.draw();
      renderer.draw(camPosition, view.maxRay);

      if (maps.loaded() < 1.0) requestAnimationFrame(animate);
    }
  }

  exports.main = main;

  return exports;

}({}));
