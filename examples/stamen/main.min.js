var app = (function (exports) {
  'use strict';

  function getExtendedContext(canvas) {
    const haveCanvas = canvas instanceof Element;
    if (!haveCanvas || canvas.tagName.toLowerCase() !== "canvas") {
      throw Error("ERROR in yawgl.getExtendedContext: not a valid Canvas!");
    }

    // developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
    //   #Take_advantage_of_universally_supported_WebGL_1_extensions
    const universalExtensions = [
      "ANGLE_instanced_arrays",
      "EXT_blend_minmax",
      "OES_element_index_unit",
      "OES_standard_derivatives",
      "OES_vertex_array_object",
      "WEBGL_debug_renderer_info",
      "WEBGL_lose_context"
    ];

    // Get a WebGL context, and extend it
    const gl = canvas.getContext("webgl");
    universalExtensions.forEach(ext => getAndApplyExtension(gl, ext));

    // Modify the shaderSource method to add a preamble
    const SHADER_PREAMBLE = `
#extension GL_OES_standard_derivatives : enable
#line 1
`;
    const shaderSource = gl.shaderSource;
    gl.shaderSource = function(shader, source) {
      const modified = (source.indexOf("GL_OES_standard_derivatives") < 0)
        ? SHADER_PREAMBLE + source
        : source;
      shaderSource.call(gl, shader, modified);
    };

    return gl;
  }

  function getAndApplyExtension(gl, name) {
    // https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html
    const ext = gl.getExtension(name);
    if (!ext) return null;

    const fnSuffix = name.split("_")[0];
    const enumSuffix = '_' + fnSuffix;

    for (const key in ext) {
      const value = ext[key];
      const isFunc = typeof value === 'function';
      const suffix = isFunc ? fnSuffix : enumSuffix;
      let name = key;
      // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc
      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }
      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          console.warn("conflict:", name, gl[name], value, key);
        }
      } else if (isFunc) {
        gl[name] = (function(origFn) {
          return function() {
            return origFn.apply(ext, arguments);
          };
        })(value);
      } else {
        gl[name] = value;
      }
    }

    return ext;
  }

  function initView(porthole, fieldOfView) {
    // The porthole is an HTML element acting as a window into a 3D world
    // fieldOfView is the vertical view angle range in degrees (floating point)

    // Compute values for transformation between the 3D world and the 2D porthole
    var portRect, width, height, aspect;
    var tanFOV = Math.tan(fieldOfView * Math.PI / 180.0 / 2.0);
    const maxRay = [];

    computeRayParams(); // Set initial values

    return {
      element: porthole, // Back-reference
      changed: computeRayParams,

      width: () => width,
      height: () => height,
      topEdge: () => maxRay[1],   // tanFOV
      rightEdge: () => maxRay[0], // aspect * tanFOV
      maxRay, // TODO: is it good to expose local state?
      getRayParams,
    };

    function computeRayParams() {
      // Compute porthole size
      portRect = porthole.getBoundingClientRect();
      let newWidth = portRect.right - portRect.left;
      let newHeight = portRect.bottom - portRect.top;

      // Exit if no change
      if (width === newWidth && height === newHeight) return false;

      // Update stored values
      width = newWidth;
      height = newHeight;
      aspect = width / height;
      maxRay[0] = aspect * tanFOV;
      maxRay[1] = tanFOV; // Probably no change, but it is exposed externally

      // Let the calling program know that the porthole changed
      return true;
    }

    // Convert a position on the screen into tangents of the angles
    // (relative to screen normal) of a ray shooting off into the 3D space
    function getRayParams(rayVec, clientX, clientY) {
      // NOTE strange behavior of getBoundingClientRect()
      // rect.left and .top are equal to the coordinates given by clientX/Y
      // when the mouse is at the left top pixel in the box.
      // rect.right and .bottom are NOT equal to clientX/Y at the bottom
      // right pixel -- they are one more than the clientX/Y values.
      // Thus the number of pixels in the box is given by 
      //    porthole.clientWidth = rect.right - rect.left  (NO +1 !!)
      var x = clientX - portRect.left;
      var y = portRect.bottom - clientY - 1; // Flip sign to make +y upward

      // Normalized distances from center of box. We normalize by pixel DISTANCE
      // rather than pixel count, to ensure we get -1 and +1 at the ends.
      // (Confirm by considering the 2x2 case)
      var xratio = 2 * x / (width - 1) - 1;
      var yratio = 2 * y / (height - 1) -1;

      rayVec[0] = xratio * maxRay[0];
      rayVec[1] = yratio * maxRay[1];
      //rayVec[2] = -1.0;
      //rayVec[3] = 0.0;
      return;
    }
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;
  const clipLat = (lat) => Math.min(Math.max(-maxMercLat, lat), maxMercLat);

  function scale(geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface.
    // Return value scales a (differential) distance along the plane tangent to
    // the sphere at position <geodetic> to a distance in map coordinates.
    // NOTE: ASSUMES a sphere of radius 1! Input distances should be
    //  pre-normalized by the appropriate radius
    return 1 / (2 * Math.PI * Math.cos( clipLat(geodetic[1]) ));
  }

  function lonLatToXY(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX( geodetic[0] );
    projected[1] = latToY( geodetic[1] );
    return;
  }

  function lonToX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
    var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
    Math.log( Math.tan(Math.PI / 4.0 + clipLat(lat) / 2.0) );
    // Clip range to [0,1], since y does not wrap around
    return Math.min(Math.max(0.0, y), 1.0);
  }

  function initCache(size, tileFactory) {
    // Initialize the tiles object
    const tiles = {};
    const getID = tileFactory.getID || ( zxy => zxy.join("/") );

    // Return methods for accessing and updating the tiles
    return {
      retrieve: (zxy) => getTileOrParent(zxy, 0, 0, size),
      process,
      prune,
      trim,
      getPriority: (id) => (tiles[id]) ? tiles[id].priority : undefined,
    };

    function getTileOrParent(
        zxy,        // Coordinates of the requested tile (could be more than 3D)
        sx, sy, sw  // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object, add cropping info
      let id = getID(zxy);
      let tile = tiles[id];
      let tilebox = { tile, sx, sy, sw };

      // If the tile exists and is ready, return it (along with the wrapped info)
      if (tile && tile.rendered) return tilebox;

      // Looks like the tile wasn't ready. Try using the parent tile
      if (zxy[0] > 0 && sw > 1) { // Don't look too far back
        let [z, x, y] = zxy;

        // Get coordinates of the parent tile
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        // Copy any additional coordinates beyond the first 3
        let pzxy = [pz, px, py, ...zxy.slice(3)];

        // Compute cropping parameters for the parent
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        // Get the parent tile. Recursive!
        tilebox = getTileOrParent(pzxy, psx, psy, psw);
      }

      // If the requested tile didn't exist, we need to order it from the factory
      // NOTE: orders are placed AFTER the recursive call for the parent tile,
      // so missing parents will be ordered first
      if (!tile) {
        // For backwards compatibility, assume tileFactory.create still takes
        // a list of coordinates as arguments
        let newTile = tileFactory.create(...zxy);
        if (newTile) tiles[id] = newTile;
      } else if (tileFactory.redraw) {
        // Tile exists but isn't ready. Make sure it is rendering
        tileFactory.redraw(tile);
      }

      return (tilebox && tilebox.tile && tilebox.tile.rendered)
        ? tilebox
        : undefined;
    }

    function process(func) {
      Object.values(tiles).forEach( tile => func(tile) );
    }

    function prune(metric, threshold) {
      // Update tile priorities using the supplied metric. ASSUMES 3 args!
      process(tile => { tile.priority = metric(tile.z, tile.x, tile.y); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function trim(metric, threshold) {
      // Update tile priorities using the supplied metric
      process(tile => { tile.priority = metric(tile); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function drop(threshold) {
      var numTiles = 0;
      for (let id in tiles) {
        if (tiles[id].priority > threshold) {
          tiles[id].cancel();
          delete tiles[id];
        } else {
          numTiles ++;
        }
      }
      return numTiles;
    }
  }

  function initRasterCache(tileSize, getURL) {
    return initCache( tileSize, initRasterFactory(getURL) );
  }

  // Basic tile factory for raster data
  function initRasterFactory(getURL) {
    // Input getURL returns a tile URL for given indices z, x, y, t  (t optional)

    return { create };

    function create(z,x, y, t) {
      const tileHref = getURL(z, x, y, t);
      const img = loadImage(tileHref, checkData);

      const tile = { 
        z, x, y, t,  // t may be undefined, for 3D tile services
        img,
        cancel,
        canceled: false,
        rendered: false,
      };

      function checkData(err) {
        if (tile.canceled) return;
        if (err) return console.log(err);
        tile.rendered = true;
      }

      function cancel() {
        img.src = "";
        tile.canceled = true;
      }

      return tile;
    }
  }

  function loadImage(href, callback) {
    const errMsg = "ERROR in loadImage for href " + href;

    const img = new Image();
    img.onerror = () => callback(errMsg);
    img.onload = checkImg;
    img.crossOrigin = "anonymous";
    img.src = href;

    return img;

    function checkImg() {
      return (img.complete && img.naturalWidth !== 0)
        ? callback(null)
        : callback(errMsg);
    }
  }

  function setParams(userParams) {
    const params = {};

    params.getTile = userParams.getTile;

    params.tileSize = userParams.tileSize || 512;

    // Get canvas context, and set width/height parameters
    if (userParams.context) {
      params.context = userParams.context;
      params.width = userParams.width || params.context.canvas.width;
      params.height = userParams.height || params.context.canvas.height;
    } else {
      params.context = document.createElement("canvas").getContext("2d");
      params.width = userParams.width || 1024;
      params.height = userParams.height || 1024;
    }

    // Compute number of tiles in each direction.
    params.nx = Math.floor(params.width / params.tileSize);
    params.ny = Math.floor(params.height / params.tileSize);
    if (params.nx * params.tileSize !== params.width ||
        params.ny * params.tileSize !== params.height ) {
      console.log("width, height, tileSize = " +
          params.width + ", " + params.height + ", " + params.tileSize);
      return console.log("ERROR: width, height are not multiples of tileSize!!");
    }
    console.log("map size: " + params.width + "x" + params.height);

    // Define a min zoom (if not supplied), such that there are always enough
    // tiles to cover the grid without repeating
    params.minZoom = (userParams.minZoom === undefined)
      ? Math.floor( Math.min(Math.log2(params.nx), Math.log2(params.ny)) )
      : Math.max(0, Math.floor(userParams.minZoom));
    // Make sure any supplied max zoom is an integer larger than minZoom
    params.maxZoom = (userParams.maxZoom === undefined)
      ? 22
      : Math.max(params.minZoom, Math.floor(userParams.maxZoom));
    // Make sure initial zoom is an integer within range
    params.zoom = (userParams.zoom === undefined)
      ? params.minZoom
      : Math.floor(userParams.zoom);
    params.zoom = Math.min(Math.max(params.minZoom, params.zoom), params.maxZoom);

    // Set the initial center of the map
    params.center = userParams.center || [0.5, 0.5], // X, Y in map coordinates
    params.center[0] = Math.min(Math.max(0.0, params.center[0]), 1.0);
    params.center[1] = Math.min(Math.max(0.0, params.center[1]), 1.0);

    return params;
  }

  function initBoundingBox(params, setCenterZoom) {

    return function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of X/Y coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (numTiles - 1) / 2 ** zoom > boxSize in both X and Y
      var zoomX = Math.log2( (params.nx - 1) / boxWidth );
      var zoomY = Math.log2( (params.ny - 1) / boxHeight );

      // Compute the coordinates of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0);
      if (centerX > 1) centerX -= 1;
      var centerY = 0.5 * (p1[1] + p2[1]);

      return setCenterZoom( [centerX, centerY], Math.min(zoomX, zoomY) );
    }
  }

  function initTileCoords( params ) {
    // TODO: verify code for non-Mercator projections. Assumes x is periodic

    var zoom, nTiles, xTile0, yTile0;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    // Set initial values
    setCenterZoom(params.center, params.zoom);

    return {
      // Methods to report info about current map state
      getScale: (i) => scale[i],
      getZXY,

      // Methods to compute positions within current map
      toLocal,
      xyToMapPixels,

      // Methods to update map state
      setCenterZoom,
      fitBoundingBox: initBoundingBox(params, setCenterZoom),
      move,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
    }

    function toLocal(local, global) {
      // TODO: wrapping is problematic
      local[0] = wrap(global[0] - origin[0], 1.0) * scale[0];
      local[1] = (global[1] - origin[1]) * scale[1];
    }

    function xyToMapPixels(local, global) {
      toLocal(local, global);
      local[0] *= params.width;
      local[1] *= params.height;
    }

    function setCenterZoom(center, zNew) {
      // 1. Make sure the supplied zoom is within range and an integer
      zNew = Math.min(Math.max(params.minZoom, zNew), params.maxZoom);
      zNew = Math.floor(zNew); // TODO: should this be Math.round() ?
      var nTnew = 2 ** zNew; // Number of tiles at this zoom level

      // 2. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      var x0new = Math.round(center[0] * nTnew - params.nx / 2.0);
      x0new = wrap(x0new, nTnew); // in case we crossed the antimeridian

      var y0new = Math.round(center[1] * nTnew - params.ny / 2.0);
      y0new = Math.min(Math.max(0, y0new), nTnew - params.ny); // Don't cross pole

      // 3. Return a flag indicating whether map parameters were updated
      return updateTransform(zNew, x0new, y0new);
    }

    function move(dz, dx, dy) {
      var dzi = Math.round(dz);
      var dxi = Math.round(dx);
      var dyi = Math.round(dy);

      // Panning first
      var x0new = wrap(xTile0 + dxi, nTiles);
      var y0new = wrap(yTile0 + dyi, nTiles);

      var zNew = zoom;
      while (dzi > 0 && zNew < params.maxZoom) {  // Zoom in
        zNew++;
        x0new = Math.floor(2 * x0new + params.nx / 2.0);
        y0new = Math.floor(2 * y0new + params.ny / 2.0);
        dzi--;
      }
      while (dzi < 0 && zNew > params.minZoom) {  // Zoom out
        zNew--;
        x0new = wrap( Math.ceil( (x0new - params.nx / 2.0) / 2 ), 2 ** zNew );
        y0new = wrap( Math.ceil( (y0new - params.ny / 2.0) / 2 ), 2 ** zNew );
        dzi++;
      }

      return updateTransform(zNew, x0new, y0new);
    }

    function updateTransform(zNew, x0new, y0new) {
      if (zNew === zoom && x0new === xTile0 && y0new === yTile0) return false;

      zoom = zNew;
      xTile0 = x0new;
      yTile0 = y0new;

      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / params.nx; // Problematic if < 1 ?
      scale[1] = nTiles / params.ny;

      return true;
    }
  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initRenderer(params) {
    const context = params.context;
    const size = params.tileSize;

    // Resize drawingbuffer to fit the specified number of tiles
    context.canvas.width = params.width;
    context.canvas.height = params.height;

    return {
      draw,
      clear,
    };

    function clear() {
      return context.clearRect(0, 0, params.width, params.height);
    }

    function draw(tilebox, ix, iy) {
      context.drawImage(
          tilebox.tile.img,  // Image to read, and paint to the canvas
          tilebox.sx,        // First x-pixel in tile to read
          tilebox.sy,        // First y-pixel in tile to read
          tilebox.sw,        // Number of pixels to read in x
          tilebox.sw,        // Number of pixels to read in y
          ix * size,         // First x-pixel in canvas to paint
          iy * size,         // First y-pixel in canvas to paint
          size,              // Number of pixels to paint in x
          size               // Number of pixels to paint in y
          );
      return;
    }
  }

  function initGrid(params, coords, renderer) {
    const boxes = Array.from(Array(params.ny), () => []);

    const oneTileComplete = 1. / params.nx / params.ny;
    var complete = 0.0;

    return {
      loaded: () => complete,
      getBox: (ix, iy) => (boxes[iy]) ? boxes[iy][ix] : undefined,
      drawTiles,
      reset,
    };

    function drawTiles() {
      var updated = false;
      if (complete === 1.0) return updated; // Map is complete, no change!
      const zxy = [];

      for (let iy = 0; iy < params.ny; iy++) {
        var row = boxes[iy];
        for (let ix = 0; ix < params.nx; ix++) {
          coords.getZXY(zxy, ix, iy);
          var currentZ = (row[ix]) 
            ? row[ix].tile.z
            : undefined;
          if (currentZ === zxy[0]) continue; // This tile already done

          var newbox = params.getTile( zxy );
          if (!newbox) continue; // No image available for this tile
          if (newbox.tile.z === currentZ) continue; // Tile already written

          row[ix] = newbox;
          renderer.draw(newbox, ix, iy);
          updated = true;

          if (newbox.tile.z === zxy[0]) complete += oneTileComplete;
        }
      }
      return updated;
    }

    function reset() {
      boxes.forEach(row => { row.length = 0; });
      complete = 0.0;
    }
  }

  function initTileMetric(params, getZXY) {
    const zxy = [];

    return function(tile) {
      // Get distances of the tile from the current map
      let dist = getDiffs(tile);
      
      // Use the largest horizontal distance, and adjust for zoom difference
      return Math.max(dist.dx, dist.dy) - 1.0 + 1.0 / 2 ** dist.dz;
    }

    function getDiffs(tile) {
      // Store coordinates of the corners of the map
      getZXY(zxy, 0, 0);
      let mb = {
        x1: zxy[1],
        x2: zxy[1] + params.nx + 1, // Note: may extend across antimeridian!
        y1: zxy[2],
        y2: zxy[2] + params.ny + 1,
      };

      // Store tile corners. Convert x, y to equivalent values at MAP zoom level
      let dz = zxy[0] - tile.z;
      let zoomFac = 2 ** dz;
      let tb = {
        x1: tile.x * zoomFac,
        x2: (tile.x + 1) * zoomFac,
        y1: tile.y * zoomFac,
        y2: (tile.y + 1) * zoomFac,
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      let nTiles = 2 ** zxy[0];
      let dx = Math.min( // Be careful with the antimeridian
        // Test for non-intersection with tile in raw position
        Math.max(mb.x1 - tb.x2, tb.x1 - mb.x2),
        // Re-test with tile shifted across antimeridian
        Math.max(mb.x1 - (tb.x2 + nTiles), tb.x1 + nTiles - mb.x2)
      );
      let dy = Math.max(mb.y1 - tb.y2, tb.y1 - mb.y2);

      return { dz, dx, dy };
    }
  }

  function init(userParams) {
    const params = setParams(userParams);
    if (!params) return;

    const coords = initTileCoords(params);
    const renderer = initRenderer(params);
    const grid = initGrid(params, coords, renderer);

    return {
      canvas: params.context.canvas,

      // Report status or data
      loaded: grid.loaded,
      getTilePos,
      // Methods to clear or update the canvas
      reset: grid.reset,
      clear,
      drawTiles: grid.drawTiles,

      // Coordinate methods to set the position and zoom of the map
      move:       (dz, dx, dy) => { if (coords.move(dz, dx, dy))       clear(); },
      fitBoundingBox: (p1, p2) => { if (coords.fitBoundingBox(p1, p2)) clear(); },
      setCenterZoom:    (c, z) => { if (coords.setCenterZoom(c, z))    clear(); },

      // Methods to convert coordinates, or report conversion parameters
      toLocal:       coords.toLocal,
      xyToMapPixels: coords.xyToMapPixels,
      getScale:      coords.getScale,

      // Metric to evaluate distance of a tile from the current grid
      tileDistance: initTileMetric(params, coords.getZXY),
    };

    function getTilePos(mapXY) {
      // Get indices to the tile box
      let fx = mapXY[0] / params.tileSize;
      let fy = mapXY[1] / params.tileSize;
      let ix = Math.floor(fx);
      let iy = Math.floor(fy);

      // Get the tile box itself
      let box = grid.getBox(ix, iy);
      if (!box) return;

      // Compute position and scaling within the tile
      let x = (fx - ix) * box.sw + box.sx;
      let y = (fy - iy) * box.sw + box.sy;
      let frac = box.sw / params.tileSize; // Fraction of the tile being used

      // Return the tile along with the projected position and scaling info
      return { x, y, frac, tile: box.tile };
    }

    function clear() { // TODO: Do we ever need grid.reset without clear?
      grid.reset();
      renderer.clear();
    }
  }

  function initClipMaps(mapParams, nLod) {
    // Create an array of maps, to be maintained at different resolutions
    // or "levels of detail" (LOD)
    const frames = Array.from(Array(nLod), () => init(mapParams));

    // Isolate the canvas data for return, and add texture coordinate info
    const textures = frames.map(frame => {
      return {
        canvas: frame.canvas,
        camPos: new Float64Array(2), // Camera position within canvas
        scale: new Float64Array(2),  // Scale of canvas relative to world map
        changed: true, // Flags whether the canvas has changed since last check
      };
    });

    // Return methods to query and update the array as one map
    return {
      textures,
      loaded: () => frames.reduce((sum, f) => sum + f.loaded() / nLod, 0),
      getTilePos,

      reset: () => frames.forEach(f => f.reset()),
      drawTiles,

      setCenterZoom,
      tileDistance: (tile) => Math.min(...frames.map(f => f.tileDistance(tile))),
    };

    function getTilePos(globalXY) {
      let tilePos, mapXY = [];

      // Get the highest resolution tile possible:
      //  start from last level, drop down to lower zooms as needed
      let level = nLod;
      while(level > 0 && !tilePos) {
        level--;
        frames[level].xyToMapPixels(mapXY, globalXY);
        tilePos = frames[level].getTilePos(mapXY);
      }
      return tilePos;
    }

    function drawTiles() {
      frames.forEach((frame, i) => { textures[i].changed = frame.drawTiles(); });
    }

    function setCenterZoom(center, zoom) {
      frames.forEach( (frame, index) => {
        // Set increasing zoom levels, up to last map with z = zoom
        let z = zoom - nLod + index + 1;
        frame.setCenterZoom(center, z);

        // Update texture coordinate transform parameters
        let texture = textures[index];
        frame.toLocal(texture.camPos, center);
        texture.scale[0] = frame.getScale(0);
        texture.scale[1] = frame.getScale(1);
      });
    }
  }

  function initMaps(mapParams) {
    // Wrapper for maps. Handles projection of spherical coordinates
    const xy = new Float64Array(2);
    const tileSize = mapParams.tileSize;

    const cache = initRasterCache(tileSize, tileURL);
    var numCachedTiles = 0;

    // Initialize array of 2D map grids
    mapParams.getTile = cache.retrieve;
    const maps = initClipMaps(mapParams, 2);

    return {
      textures: maps.textures,
      loaded: maps.loaded,

      setPosition,
      draw,
    };

    function setPosition(camPos, radius, view) {
      // Get map zoom
      let dMap = camPos[2] / radius *        // Normalize to radius = 1
        view.topEdge() * 2 / view.height() * // ray tangent per pixel
        scale(camPos);            // Scale assumes sphere radius = 1
      let zoom = Math.round( -Math.log2(tileSize * dMap) );

      lonLatToXY(xy, camPos);
      maps.setCenterZoom(xy, zoom);
    }

    function draw() {
      maps.drawTiles();
      numCachedTiles = cache.trim(maps.tileDistance, 1.5);
    }
  }

  function tileURL(z, x, y) {
    const endpoint = "http://tile.stamen.com/toner-lite/{z}/{x}/{y}.png";
    return endpoint.replace(/{z}/, z).replace(/{x}/, x).replace(/{y}/, y);
  }

  function resizeCanvasToDisplaySize(canvas, multiplier) {
    // Make sure the canvas drawingbuffer is the same size as the display
    // webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

    // multiplier allows scaling. Example: multiplier = window.devicePixelRatio
    if (!multiplier || multiplier < 0) multplier = 1;

    const width = Math.floor(canvas.clientWidth * multiplier);
    const height = Math.floor(canvas.clientHeight * multiplier);

    // Exit if no change
    if (canvas.width === width && canvas.height === height) return false;

    // Resize drawingbuffer to match resized display
    canvas.width = width;
    canvas.height = height;
    return true;
  }

  function initQuadBuffers(gl) {
    // 4 vertices at the corners of the quad
    const vertices = [ -1, -1,  0,    1, -1,  0,    1,  1,  0,   -1,  1,  0 ];
    // Store byte info and load into GPU
    const vertexPositions = {
      buffer: gl.createBuffer(),
      numComponents: 3,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    // Bind to the gl context
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositions.buffer);
    // Pass the array into WebGL
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Texture coordinates assume image has 0,0 at top left
    const texCoordData = [ 0, 1,   1, 1,   1, 0,   0, 0 ];
    const texCoords = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoords.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoordData), gl.STATIC_DRAW);

    // Index into two triangles
    var indices = [ 0,  1,  2,    2,  3,  0 ];
    const vertexIndices = {
      buffer: gl.createBuffer(),
      vertexCount: indices.length,
      type: gl.UNSIGNED_SHORT,
      offset: 0
    };
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndices.buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    return {
      attributes: {
        aVertexPosition: vertexPositions,
        aTexCoord: texCoords,
      },
      indices: vertexIndices,
    };
  }

  function createAttributeSetters(gl, program) {
    // Very similar to greggman's module:
    // webglfundamentals.org/docs/module-webgl-utils.html#.createAttributeSetters
    var attribSetters = {};
    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttribs; i++) {
      var attribInfo = gl.getActiveAttrib(program, i);
      if (!attribInfo) break;
      var index = gl.getAttribLocation(program, attribInfo.name);
      attribSetters[attribInfo.name] = createAttribSetter(gl, index);
    }
    return attribSetters;
  }

  function createAttribSetter(gl, index) {
    return function(b) {
      // Enable this attribute (shader attributes are disabled by default)
      gl.enableVertexAttribArray(index);
      // Bind the buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
      // Point the attribute in the program to this buffer,
      // and tell the program the byte layout in the buffer
      gl.vertexAttribPointer(
          index,                      // index of attribute in program
          b.numComponents || b.size,  // Number of elements to read per vertex
          b.type || gl.FLOAT,         // Type of each element
          b.normalize || false,       // Whether to normalize it
          b.stride || 0,              // Byte spacing between vertices
          b.offset || 0               // Byte # to start reading from
          );
    };
  }

  function setBuffersAndAttributes(gl, setters, buffers) {
    setAttributes(setters, buffers.attributes);
    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices.buffer);
    }
  }

  function setAttributes(setters, attribs) {
    Object.keys(attribs).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter( attribs[name] );
    });
  }

  function createUniformSetters(gl, program) {
    // Very similar to greggman's module:
    // webglfundamentals.org/docs/module-webgl-utils.html#.createUniformSetters

    // Track texture bindpoint index in case multiple textures are required
    var textureUnit = 0;

    const uniformSetters = {};
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (let i = 0; i < numUniforms; i++) {
      let uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) break;

      let { name, type, size } = uniformInfo;
      let loc = gl.getUniformLocation(program, name);

      // getActiveUniform adds a suffix to the names of arrays
      let isArray = (name.slice(-3) === "[0]");
      let key = (isArray)
        ? name.slice(0, -3)
        : name;

      uniformSetters[key] = createUniformSetter(loc, type, isArray, size);
    }

    return uniformSetters;

    // This function must be nested to access the textureUnit index
    function createUniformSetter(loc, type, isArray, size) {
      switch (type) {
        case gl.FLOAT:
          return (isArray)
            ? (v) => gl.uniform1fv(loc, v)
            : (v) => gl.uniform1f(loc, v);
        case gl.FLOAT_VEC2:
          return (v) => gl.uniform2fv(loc, v);
        case gl.FLOAT_VEC3:
          return (v) => gl.uniform3fv(loc, v);
        case gl.FLOAT_VEC4:
          return (v) => gl.uniform4fv(loc, v);
        case gl.INT:
          return (isArray)
            ? (v) => gl.uniform1iv(loc, v)
            : (v) => gl.uniform1i(loc, v);
        case gl.INT_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.INT_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.INT_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.BOOL:
          return (v) => gl.uniform1iv(loc, v);
        case gl.BOOL_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.BOOL_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.BOOL_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.FLOAT_MAT2:
          return (v) => gl.uniformMatrix2fv(loc, false, v);
        case gl.FLOAT_MAT3:
          return (v) => gl.uniformMatrix3fv(loc, false, v);
        case gl.FLOAT_MAT4:
          return (v) => gl.uniformMatrix4fv(loc, false, v);
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          var bindPoint = getBindPointForSamplerType(gl, type);
          if (isArray) {
            var units = Array.from(Array(size), () => textureUnit++);
            return function(textures) {
              gl.uniform1iv(loc, units);
              textures.forEach( function(texture, index) {
                gl.activeTexture(gl.TEXTURE0 + units[index]);
                gl.bindTexture(bindPoint, texture);
              });
            };
          } else {
            var unit = textureUnit++;
            return function(texture) {
              gl.uniform1i(loc, unit);
              gl.activeTexture(gl.TEXTURE0 + unit);
              gl.bindTexture(bindPoint, texture);
            };
          }
       default:  // we should never get here
          throw("unknown type: 0x" + type.toString(16));
      }
    }
  }

  function getBindPointForSamplerType(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;
    return undefined;
  }

  function setUniforms(setters, values) {
    Object.entries(values).forEach(([key, val]) => {
      var setter = setters[key];
      if (setter) setter(val);
    });
  }

  // Initialize a shader program
  function initShaderProgram(gl, vsSource, fsSource) {
    // NOTE: Load any WebGL extensions before calling this

    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      throw Error('Unable to initialize the shader program: \n' +
          gl.getProgramInfoLog(shaderProgram) );
    }

    return {
      program: shaderProgram,
      attributeSetters: createAttributeSetters(gl, shaderProgram),
      uniformSetters: createUniformSetters(gl, shaderProgram),
    };
  }

  // create shader of a given type, upload source, compile it
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw Error('An error occurred compiling the shaders: \n' +
          gl.getShaderInfoLog(shader) );
    }

    return shader;
  }

  function drawScene(gl, programInfo, bufferInfo, uniforms, viewport) {
    // Make a blank canvas that fills the displayed size from CSS
    prepCanvas(gl, viewport);

    // Tell WebGL to use our program when drawing
    gl.useProgram(programInfo.program);

    // Prepare shader attributes.
    setBuffersAndAttributes( gl, programInfo.attributeSetters, bufferInfo );
    // Set the shader uniforms
    setUniforms( programInfo.uniformSetters, uniforms );

    // Draw the scene
    gl.drawElements(gl.TRIANGLES, bufferInfo.indices.vertexCount,
        bufferInfo.indices.type, bufferInfo.indices.offset);

    // Turn off the scissor test for now  TODO: is this necessary?
    gl.disable(gl.SCISSOR_TEST);
  }

  function prepCanvas(gl, port) {
    // Set some parameters
    gl.clearColor(0.0, 0.0, 0.0, 0.0);  // Clear to transparent black
    gl.clearDepth(1.0);                 // Clear everything
    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

    // Tell WebGL how to convert from clip space to pixels
    if (port !== undefined) {
      gl.viewport(port.left, port.bottom, port.width, port.height);
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(port.left, port.bottom, port.width, port.height);
    } else {
      // Use the whole canvas
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }

    // Clear the canvas AND the depth buffer
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    return;
  }

  function setupMipMaps(gl, target, width, height) {
    // We are using WebGL1 (for compatibility with mobile browsers) which can't
    // handle mipmapping for non-power-of-2 images. Maybe we should provide
    // pre-computed mipmaps? see https://stackoverflow.com/a/21540856/10082269
    if (isPowerOf2(width) && isPowerOf2(height)) {
      gl.generateMipmap(target);
      // Clamp to avoid wrapping around poles
      // TODO: this may not work with circular coordinates?
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    } else { // Turn off mipmapping 
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // Set wrapping to clamp to edge
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    return;
  }

  function setTextureAnisotropy(gl, target) {
    var ext = (
        gl.getExtension('EXT_texture_filter_anisotropic') ||
        gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || 
        gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        );
    if (ext) {
      var maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      // BEWARE: this texParameterf call is slow on Intel integrated graphics.
      // Avoid this entire function if at all possible.
      gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, 
          maxAnisotropy);
    }
    return;
  }

  function isPowerOf2(value) {
    // This trick uses bitwise operators.
    // See https://stackoverflow.com/a/30924333/10082269
    return value && !(value & (value - 1));
    // For a better explanation, with some errors in the solution, see
    // https://stackoverflow.com/a/30924360/10082269
  }

  function initTexture(gl, width, height) {
    // Initializes a 2D texture object, extending the default gl.createTexture()
    // The GL context and the binding target are implicitly saved in the closure.
    // Returns the sampler (as a property) along with update and replace methods.
    // Input data is an ImageData object

    const target = gl.TEXTURE_2D;
    const texture = gl.createTexture();
    gl.bindTexture(target, texture);

    // Initialize with default parameters
    const level = 0;  // Mipmap level
    const internalFormat = gl.RGBA;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;
    const border = 0;

    gl.texImage2D(target, level, internalFormat, width, height, border,
        srcFormat, srcType, null);

    // Set up mipmapping and anisotropic filtering, if appropriate
    setupMipMaps(gl, target, width, height);
    setTextureAnisotropy(gl, target);

    return {
      sampler: texture,
      replace,
      update,
    }

    function replace( image ) {
      // Replaces the texture with the supplied image data
      // WARNING: will change texture width/height to match the image
      gl.bindTexture(target, texture);
      gl.texImage2D(target, level, internalFormat, srcFormat, srcType, image);

      // Re-do mipmap setup, since width/height may have changed
      setupMipMaps(gl, target, image.width, image.height);
      return;
    }

    function update( image ) {
      // Updates a portion of the texture with the supplied image data.
      gl.bindTexture(target, texture);

      // Image will be written starting from the pixel (xoffset, yoffset).
      // If these values are not set on the input, use (0,0)
      var xoff = image.xoffset || 0;
      var yoff = image.yoffset || 0;
      gl.texSubImage2D(target, level, xoff, yoff, srcFormat, srcType, image);

      setupMipMaps(gl, target, image.width, image.height);
      return;
    }
  }

  function setParams$1(userParams) {
    const params = {};

    params.getPixelRatio = (userParams.pixelRatio)
      ? () => userParams.pixelRatio
      : () => window.devicePixelRatio;
    // NOTE: getPixelRatio() returns the result of an object getter,
    //       NOT the property value at the time of getPixelRatio definition
    //  Thus, getPixelRatio will mirror any changes in the parent object

    params.globeRadius = userParams.globeRadius || 6371;

    params.maps = Array.isArray(userParams.map)
      ? userParams.map
      : [userParams.map];
    params.nMaps = params.maps.length;

    if (userParams.gl instanceof WebGLRenderingContext) {
      params.gl = userParams.gl;
    } else {
      throw("satellite-view: no valid WebGLRenderingContext!");
    }

    return params;
  }

  var vertexSrc = `attribute vec4 aVertexPosition;
uniform vec2 uMaxRay;

varying highp vec2 vRayParm;

void main(void) {
  vRayParm = uMaxRay * aVertexPosition.xy;
  gl_Position = aVertexPosition;
}
`;

  var invertSrc = `uniform float uLat0;
uniform float uCosLat0;
uniform float uSinLat0;
uniform float uTanLat0;

float latChange(float x, float y, float sinC, float cosC) {
  float xtan = x * uTanLat0;
  float curveTerm = 0.5 * y * (xtan * xtan - y * y / 3.0);

  return (max(sinC, abs(sinC * uTanLat0) ) < 0.1)
    ? sinC * (y - sinC * (0.5 * xtan * x + curveTerm * sinC))
    : asin(uSinLat0 * cosC + y * uCosLat0 * sinC) - uLat0;
}

vec2 xyToLonLat(vec2 xy, float sinC, float cosC) {
  vec2 pHat = normalize(xy);
  float dLon = atan(pHat.x * sinC,
      uCosLat0 * cosC - pHat.y * uSinLat0 * sinC);
  float dLat = latChange(pHat.x, pHat.y, sinC, cosC);
  return vec2(dLon, dLat);
}
`;

  var projectSrc = `const float ONEOVERTWOPI = 0.15915493667125702;

uniform float uExpY0;
uniform float uLatErr; // Difference of clipping to map limit

float smallTan(float x) {
  return (abs(x) < 0.1)
    ? x * (1.0 + x * x / 3.0)
    : tan(x);
}

float log1plusX(float x) {
  return (abs(x) < 0.15)
    ? x * (1.0 - x * (0.5 - x / 3.0 + x * x / 4.0))
    : log( 1.0 + max(x, -0.999) );
}

vec2 projMercator(vec2 dLonLat) {
  float tandlat = smallTan( 0.5 * (dLonLat[1] + uLatErr) );
  float p = tandlat * uExpY0;
  float q = tandlat / uExpY0;
  return vec2(dLonLat[0], log1plusX(-p) - log1plusX(q)) * ONEOVERTWOPI;
}
`;

  function glslInterp(strings, ...expressions) {
    return strings.reduce( (acc, val, i) => acc + expressions[i-1]() + val );
  }
  var texLookup = (args) => glslInterp`const int nLod = ${args.nLod};

uniform sampler2D uTextureSampler[nLod];
uniform vec2 uCamMapPos[nLod];
uniform vec2 uMapScales[nLod];

float dateline(float x1) {
  // Choose the correct texture coordinate in fragments crossing the
  // antimeridian of a cylindrical coordinate system
  // See http://vcg.isti.cnr.it/~tarini/no-seams/

  // Alternate coordinate: forced across the antimeridian
  float x2 = fract(x1 + 0.5) - 0.5;
  // Choose the coordinate with the smaller screen-space derivative
  return (fwidth(x1) < fwidth(x2) + 0.001) ? x1 : x2;
}

bool inside(vec2 pos) {
  // Check if the supplied texture coordinate falls inside [0,1] X [0,1]
  // We adjust the limits slightly to ensure we are 1 pixel away from the edges
  return (
      0.001 < pos.x && pos.x < 0.999 &&
      0.001 < pos.y && pos.y < 0.999 );
}

vec4 sampleLOD(sampler2D samplers[nLod], vec2 coords[nLod]) {
  return ${args.buildSelector}texture2D(samplers[0], coords[0]);
}

vec4 texLookup(vec2 dMerc) {
  vec2 texCoords[nLod];

  for (int i = 0; i < nLod; i++) {
    texCoords[i] = uCamMapPos[i] + uMapScales[i] * dMerc;
    texCoords[i].x = dateline(texCoords[i].x);
  }

  return sampleLOD(uTextureSampler, texCoords);
}
`;

  var dither2x2 = `float threshold(float val, float limit) {
  float decimal = fract(255.0 * val);
  float dithered = (decimal < limit)
    ? 0.0
    : 1.0;
  float adjustment = (dithered - decimal) / 255.0;
  return val + adjustment;
}

vec3 dither2x2(vec2 position, vec3 color) {
  // Based on https://github.com/hughsk/glsl-dither/blob/master/2x2.glsl
  int x = int( mod(position.x, 2.0) );
  int y = int( mod(position.y, 2.0) );
  int index = x + y * 2;

  float limit = 0.0;
  if (index == 0) limit = 0.25;
  if (index == 1) limit = 0.75;
  if (index == 2) limit = 1.00;
  if (index == 3) limit = 0.50;

  // Use limit to toggle color between adjacent 8-bit values
  return vec3(
      threshold(color.r, limit),
      threshold(color.g, limit),
      threshold(color.b, limit)
      );
}
`;

  var fragMain = `float diffSqrt(float x) {
  // Returns 1 - sqrt(1-x), with special handling for small x
  float halfx = 0.5 * x;
  return (x < 0.1)
    ? halfx * (1.0 + 0.5 * halfx * (1.0 + halfx))
    : 1.0 - sqrt(1.0 - x);
}

float horizonTaper(float gamma) {
  // sqrt(gamma) = tan(ray_angle) / tan(horizon)
  float horizonRatio = sqrt(gamma);
  float delta = 2.0 * fwidth(horizonRatio);
  return 1.0 - smoothstep(1.0 - delta, 1.0, horizonRatio);
}

varying vec2 vRayParm;
uniform float uHnorm;

void main(void) {
  // 0. Pre-compute some values
  float p = length(vRayParm); // Tangent of ray angle
  float p2 = p * p;
  float gamma = p2 * uHnorm * (2.0 + uHnorm);
  float sinC = (uHnorm + diffSqrt(gamma)) * p / (1.0 + p2);
  float cosC = sqrt(1.0 - sinC * sinC);

  // 1. Invert for longitude and latitude perturbations relative to camera
  vec2 dLonLat = xyToLonLat(vRayParm, sinC, cosC);

  // 2. Project to a change in the Mercator coordinates
  vec2 dMerc = projMercator(dLonLat);

  // 3. Lookup color from the appropriate texture
  vec4 texelColor = texLookup(dMerc);

  // Add cosine shading, dithering, and horizon tapering
  vec3 dithered = dither2x2(gl_FragCoord.xy, cosC * texelColor.rgb);
  gl_FragColor = vec4(dithered.rgb, texelColor.a) * horizonTaper(gamma);
}
`;

  const header = `
precision highp float;
precision highp sampler2D;

`;

  function buildShader(nLod) {
    // Input nLod is the number of 'levels of detail' supplied
    // in the set of multi-resolution maps
    nLod = Math.max(1, Math.floor(nLod));

    // Execute the 'tagged template literal' added to texLookup.js.glsl by
    // ../../build/glsl-plugin.js. This will substitute nLod-dependent code
    const args = { // Properties MUST match ./texLookup.js.glsl
      nLod: () => nLod,
      buildSelector: () => buildSelector(nLod),
    };
    const texLookupSrc = texLookup(args);

    // Combine the GLSL-snippets into one shader source
    const fragmentSrc = header + invertSrc + projectSrc + 
      texLookupSrc + dither2x2 + fragMain;

    return {
      vert: vertexSrc,
      frag: fragmentSrc,
    };
  }

  function buildSelector(n) {
    // In the texLookup code, add lines to check each of the supplied textures,
    // and sample the highest LOD that contains the current coordinate
    var selector = ``;
    while (--n) selector += `inside(coords[${n}])
    ? texture2D(samplers[${n}], coords[${n}])
    : `;
    return selector;
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat$1 = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function getWebMercatorFactors(camLatitude) {
    // Clip latitude to map limits
    var clipLat = Math.min(Math.max(-maxMercLat$1, camLatitude), maxMercLat$1);
    var latErr = camLatitude - clipLat;

    // camera exp(Y), for converting delta latitude to delta Y
    var expY = Math.tan( 0.25 * Math.PI + 0.5 * clipLat );

    return [expY, latErr];
  }

  function init$1(userParams) {
    const params = setParams$1(userParams);
    const gl = params.gl;

    // Initialize shader program
    const shaders = buildShader(params.nMaps);
    // TODO: use yawgl.initProgram
    const progInfo = initShaderProgram(gl, shaders.vert, shaders.frag);

    // Load data into GPU for shaders: attribute buffers, indices, textures
    // TODO: use the constructVao method returned by yawgl.initProgram
    const buffers = initQuadBuffers(gl);
    const textures = params.maps.map(map => {
      return initTexture(gl, map.canvas.width, map.canvas.height);
    });

    // Store links to uniform arrays
    const uniforms = {
      uMaxRay: new Float64Array(2),
      uTextureSampler: textures.map(tx => tx.sampler),
      uCamMapPos: new Float64Array(2 * params.nMaps),
      uMapScales: new Float64Array(2 * params.nMaps),
    };

    return {
      canvas: gl.canvas,
      draw,
      setPixelRatio: (ratio) => { params.getPixelRatio = () => ratio; },
      destroy: () => gl.canvas.remove(),
    };

    function draw(camPos, maxRayTan, camMoving) {
      if (!camMoving && !params.maps.some(map => map.changed)) return;

      // Update uniforms related to camera position
      uniforms.uHnorm = camPos[2] / params.globeRadius;
      uniforms.uLat0 = camPos[1];
      uniforms.uCosLat0 = Math.cos(camPos[1]);
      uniforms.uSinLat0 = Math.sin(camPos[1]);
      uniforms.uTanLat0 = Math.tan(camPos[1]);
      [uniforms.uExpY0, uniforms.uLatErr] = getWebMercatorFactors(camPos[1]);

      uniforms.uMaxRay.set(maxRayTan);

      // Set uniforms and update textures for each map
      // TODO: use a framebuffer if the map is WebGL?
      params.maps.forEach( (map, index) => {
        uniforms.uCamMapPos.set(map.camPos, 2 * index);
        uniforms.uMapScales.set(map.scale, 2 * index);
        if (map.changed) textures[index].update(map.canvas);
      });

      // Draw the globe
      // TODO: use the setupDraw method returned by yawgl.initProgram
      var resized = resizeCanvasToDisplaySize(
        gl.canvas, params.getPixelRatio() );
      drawScene(gl, progInfo, buffers, uniforms);
      return resized;
    }
  }

  const degrees = 180.0 / Math.PI;

  const mapParams = {
    tileSize: 256,
    maxZoom: 23,
    width: 1024,
    height: 1024,
  };
  const radius = 6371;

  function main() {
    var maps, requestID;
    const camPosition = new Float64Array(3);

    // Get links to lon/lat/alt inputs and display div
    const coordInput = document.getElementById("coordInput");

    const canvas = document.getElementById("globe");
    const view = initView(canvas, 25.0);
    const gl = getExtendedContext(canvas);

    // Setup coordinates interaction
    maps = initMaps(mapParams);

    const renderer = init$1({
      gl, 
      globeRadius: radius,
      map: maps.textures,
    });

    coordInput.addEventListener("input", getCoords, false);
    getCoords();

    function getCoords() {
      let coords = coordInput.elements;
      camPosition[0] = coords["lon"].value / degrees;
      camPosition[1] = coords["lat"].value / degrees;
      camPosition[2] = coords["alt"].value;

      // Start a rendering loop. Cancel running loops to avoid memory leaks
      cancelAnimationFrame(requestID);
      requestID = requestAnimationFrame(animate);
    }

    function animate(time) {
      let resized = view.changed();
      maps.setPosition(camPosition, radius, view);
      maps.draw();
      renderer.draw(camPosition, view.maxRay, true);

      if (maps.loaded() < 1.0) requestAnimationFrame(animate);
    }
  }

  exports.main = main;

  return exports;

}({}));
