var stamen = (function (exports) {
  'use strict';

  function initView(porthole, fieldOfView) {
    // The porthole is an HTML element acting as a window into a 3D world
    // fieldOfView is the vertical view angle range in degrees (floating point)

    // Compute values for transformation between the 3D world and the 2D porthole
    var portRect, width, height, aspect;
    var tanFOV = Math.tan(fieldOfView * Math.PI / 180.0 / 2.0);
    const maxRay = [];

    computeRayParams(); // Set initial values

    return {
      element: porthole, // Back-reference
      changed: computeRayParams,

      width: () => width,
      height: () => height,
      topEdge: () => maxRay[1],   // tanFOV
      rightEdge: () => maxRay[0], // aspect * tanFOV
      maxRay, // TODO: is it good to expose local state?
      getRayParams,
    };

    function computeRayParams() {
      // Compute porthole size
      portRect = porthole.getBoundingClientRect();
      let newWidth = portRect.right - portRect.left;
      let newHeight = portRect.bottom - portRect.top;

      // Exit if no change
      if (width === newWidth && height === newHeight) return false;

      // Update stored values
      width = newWidth;
      height = newHeight;
      aspect = width / height;
      maxRay[0] = aspect * tanFOV;
      maxRay[1] = tanFOV; // Probably no change, but it is exposed externally

      // Let the calling program know that the porthole changed
      return true;
    }

    // Convert a position on the screen into tangents of the angles
    // (relative to screen normal) of a ray shooting off into the 3D space
    function getRayParams(rayVec, clientX, clientY) {
      // NOTE strange behavior of getBoundingClientRect()
      // rect.left and .top are equal to the coordinates given by clientX/Y
      // when the mouse is at the left top pixel in the box.
      // rect.right and .bottom are NOT equal to clientX/Y at the bottom
      // right pixel -- they are one more than the clientX/Y values.
      // Thus the number of pixels in the box is given by 
      //    porthole.clientWidth = rect.right - rect.left  (NO +1 !!)
      var x = clientX - portRect.left;
      var y = portRect.bottom - clientY - 1; // Flip sign to make +y upward

      // Normalized distances from center of box. We normalize by pixel DISTANCE
      // rather than pixel count, to ensure we get -1 and +1 at the ends.
      // (Confirm by considering the 2x2 case)
      var xratio = 2 * x / (width - 1) - 1;
      var yratio = 2 * y / (height - 1) -1;

      rayVec[0] = xratio * maxRay[0];
      rayVec[1] = yratio * maxRay[1];
      //rayVec[2] = -1.0;
      //rayVec[3] = 0.0;
      return;
    }
  }

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function scale(geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface.
    // Return value scales a (differential) distance along the plane tangent to
    // the sphere at position <geodetic> to a distance in map coordinates.
    // NOTE: ASSUMES a sphere of radius 1! Input distances should be
    //  pre-normalized by the appropriate radius
    let clipLat = Math.min(Math.max(-maxMercLat, geodetic[1]), maxMercLat);
    return 1 / (2 * Math.PI * Math.cos(clipLat));
  }

  function lonLatToXY(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX( geodetic[0] );
    projected[1] = latToY( geodetic[1] );
    return;
  }

  function lonToX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
    var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);
    var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
    Math.log( Math.tan(Math.PI / 4.0 + clipLat / 2.0) );
    // Clip range to [0,1], since y does not wrap around
    return Math.min(Math.max(0.0, y), 1.0);
  }

  function initCache(size, tileFactory) {
    // Initialize the tiles object
    const tiles = {};
    const getID = tileFactory.getID || ( zxy => zxy.join("/") );

    // Return methods for accessing and updating the tiles
    return {
      retrieve: (zxy) => getTileOrParent(zxy, 0, 0, size),
      process,
      prune,
      trim,
      getPriority: (id) => (tiles[id]) ? tiles[id].priority : undefined,
    };

    function getTileOrParent(
        zxy,        // Coordinates of the requested tile (could be more than 3D)
        sx, sy, sw  // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object, add cropping info
      let id = getID(zxy);
      let tile = tiles[id];
      let tilebox = { tile, sx, sy, sw };

      // If the tile exists and is ready, return it (along with the wrapped info)
      if (tile && tile.rendered) return tilebox;

      // Looks like the tile wasn't ready. Try using the parent tile
      if (zxy[0] > 0 && sw > 1) { // Don't look too far back
        let [z, x, y] = zxy;

        // Get coordinates of the parent tile
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        // Copy any additional coordinates beyond the first 3
        let pzxy = [pz, px, py, ...zxy.slice(3)];

        // Compute cropping parameters for the parent
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        // Get the parent tile. Recursive!
        tilebox = getTileOrParent(pzxy, psx, psy, psw);
      }

      // If the requested tile didn't exist, we need to order it from the factory
      // NOTE: orders are placed AFTER the recursive call for the parent tile,
      // so missing parents will be ordered first
      if (!tile) {
        // For backwards compatibility, assume tileFactory.create still takes
        // a list of coordinates as arguments
        let newTile = tileFactory.create(...zxy);
        if (newTile) tiles[id] = newTile;
      } else if (tileFactory.redraw) {
        // Tile exists but isn't ready. Make sure it is rendering
        tileFactory.redraw(tile);
      }

      return (tilebox && tilebox.tile && tilebox.tile.rendered)
        ? tilebox
        : undefined;
    }

    function process(func) {
      Object.values(tiles).forEach( tile => func(tile) );
    }

    function prune(metric, threshold) {
      // Update tile priorities using the supplied metric. ASSUMES 3 args!
      process(tile => { tile.priority = metric(tile.z, tile.x, tile.y); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function trim(metric, threshold) {
      // Update tile priorities using the supplied metric
      process(tile => { tile.priority = metric(tile); });
      // Remove tiles where priority is above the threshold
      return drop(threshold);
    }

    function drop(threshold) {
      var numTiles = 0;
      for (let id in tiles) {
        if (tiles[id].priority > threshold) {
          tiles[id].cancel();
          delete tiles[id];
        } else {
          numTiles ++;
        }
      }
      return numTiles;
    }
  }

  function initRasterCache(tileSize, getURL) {
    return initCache( tileSize, initRasterFactory(getURL) );
  }

  // Basic tile factory for raster data
  function initRasterFactory(getURL) {
    // Input getURL returns a tile URL for given indices z, x, y, t  (t optional)

    return { create };

    function create(z,x, y, t) {
      const tileHref = getURL(z, x, y, t);
      const img = loadImage(tileHref, checkData);

      const tile = { 
        z, x, y, t,  // t may be undefined, for 3D tile services
        img,
        cancel,
        canceled: false,
        rendered: false,
      };

      function checkData(err) {
        if (tile.canceled) return;
        if (err) return console.log(err);
        tile.rendered = true;
      }

      function cancel() {
        img.src = "";
        tile.canceled = true;
      }

      return tile;
    }
  }

  function loadImage(href, callback) {
    const errMsg = "ERROR in loadImage for href " + href;

    const img = new Image();
    img.onerror = () => callback(errMsg);
    img.onload = checkImg;
    img.crossOrigin = "anonymous";
    img.src = href;

    return img;

    function checkImg() {
      return (img.complete && img.naturalWidth !== 0)
        ? callback(null)
        : callback(errMsg);
    }
  }

  function setParams(userParams) {
    const params = {};

    params.tileSize = userParams.tileSize || 512;

    // Get canvas context, and set width/height parameters
    if (userParams.context) {
      params.context = userParams.context;
      params.width = userParams.width || params.context.canvas.width;
      params.height = userParams.height || params.context.canvas.height;
    } else {
      params.context = document.createElement("canvas").getContext("2d");
      params.width = userParams.width || 1024;
      params.height = userParams.height || 1024;
    }

    // Compute number of tiles in each direction.
    params.nx = Math.floor(params.width / params.tileSize);
    params.ny = Math.floor(params.height / params.tileSize);
    if (params.nx * params.tileSize !== params.width ||
        params.ny * params.tileSize !== params.height ) {
      console.log("width, height, tileSize = " +
          params.width + ", " + params.height + ", " + params.tileSize);
      return console.log("ERROR: width, height are not multiples of tileSize!!");
    }
    console.log("map size: " + params.width + "x" + params.height);

    // Define a min zoom (if not supplied), such that there are always enough
    // tiles to cover the grid without repeating
    params.minZoom = (userParams.minZoom === undefined)
      ? Math.floor( Math.min(Math.log2(params.nx), Math.log2(params.ny)) )
      : Math.max(0, Math.floor(userParams.minZoom));
    // Make sure any supplied max zoom is an integer larger than minZoom
    params.maxZoom = (userParams.maxZoom === undefined)
      ? 22
      : Math.max(params.minZoom, Math.floor(userParams.maxZoom));
    // Make sure initial zoom is an integer within range
    params.zoom = (userParams.zoom === undefined)
      ? params.minZoom
      : Math.floor(userParams.zoom);
    params.zoom = Math.min(Math.max(params.minZoom, params.zoom), params.maxZoom);

    // Set the initial center of the map
    params.center = userParams.center || [0.5, 0.5], // X, Y in map coordinates
    params.center[0] = Math.min(Math.max(0.0, params.center[0]), 1.0);
    params.center[1] = Math.min(Math.max(0.0, params.center[1]), 1.0);

    return params;
  }

  // TODO: verify code for non-Mercator projections. Assumes x is periodic
  function initTileCoords( params ) {
    var zoom, nTiles, xTile0, yTile0;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    // Set initial values
    setCenterZoom(params.center, params.zoom);

    return {
      // Methods to report info about current map state
      getScale: (i) => scale[i],
      getZXY,

      // Methods to compute positions within current map
      toLocal,
      xyToMapPixels,

      // Methods to update map state
      setCenterZoom,
      fitBoundingBox,
      move,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
    }

    function toLocal(local, global) {
      // TODO: wrapping is problematic
      local[0] = wrap(global[0] - origin[0], 1.0) * scale[0];
      local[1] = (global[1] - origin[1]) * scale[1];
    }

    function xyToMapPixels(local, global) {
      toLocal(local, global);
      local[0] *= params.width;
      local[1] *= params.height;
    }

    function setCenterZoom(center, newZoom) {
      // 0. Remember old values
      var oldZ = zoom;
      var oldX = xTile0;
      var oldY = yTile0;

      // 1. Make sure the supplied zoom is within range and an integer
      zoom = Math.min(Math.max(params.minZoom, newZoom), params.maxZoom);
      zoom = Math.floor(zoom); // TODO: should this be Math.round() ?
      nTiles = 2 ** zoom; // Number of tiles at this zoom level

      // 2. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      xTile0 = Math.round(center[0] * nTiles - params.nx / 2.0);
      xTile0 = wrap(xTile0, nTiles); // in case we crossed the antimeridian

      yTile0 = Math.round(center[1] * nTiles - params.ny / 2.0);
      yTile0 = Math.min(Math.max(0, yTile0), nTiles - params.ny); // Don't cross pole

      // 3. Return a flag indicating whether map parameters were updated
      if (zoom === oldZ && xTile0 === oldX && yTile0 === oldY) return false;
      updateTransform();
      return true;
    }

    function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of X/Y coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.
      // (allows panning to where p1[0] is near the right edge of a tile.)

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (gridSize? - 1) / 2 ** zoom > boxSize in both X and Y.
      var zoomX = Math.log2( (params.nx - 1) / boxWidth );
      var zoomY = Math.log2( (params.ny - 1) / boxHeight );

      // Compute the coordinates of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0);
      if (centerX > 1) centerX -= 1;
      var centerY = 0.5 * (p1[1] + p2[1]);

      return setCenterZoom( [centerX, centerY], Math.min(zoomX, zoomY) );
    }

    function move(dz, dx, dy) {
      var dzi = Math.round(dz);
      var dxi = Math.round(dx);
      var dyi = Math.round(dy);

      // Don't zoom beyond the limits of the API
      dzi = Math.min(Math.max(0 - zoom, dzi), params.maxZoom - zoom);

      var changed = (dzi || dxi || dyi);

      // Panning first
      xTile0 = wrap(xTile0 + dxi, nTiles);
      yTile0 = wrap(yTile0 + dyi, nTiles);

      while (dzi > 0) {  // Zoom in
        zoom++;
        xTile0 = Math.floor(2 * xTile0 + params.nx / 2.0);
        yTile0 = Math.floor(2 * yTile0 + params.ny / 2.0);
        dzi--;
      }
      while (dzi < 0) {  // Zoom out
        zoom--;
        xTile0 = wrap( Math.ceil( (xTile0 - params.nx / 2.0) / 2 ), nTiles );
        yTile0 = wrap( Math.ceil( (yTile0 - params.ny / 2.0) / 2 ), nTiles );
        dzi++;
      }

      updateTransform();
      return changed;
    }

    function updateTransform() {
      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / params.nx; // Problematic if < 1 ?
      scale[1] = nTiles / params.ny;
    }
  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initRenderer(params) {
    const context = params.context;
    const size = params.tileSize;

    // Resize drawingbuffer to fit the specified number of tiles
    context.canvas.width = params.width;
    context.canvas.height = params.height;

    return {
      draw,
      clear,
    };

    function clear() {
      return context.clearRect(0, 0, params.width, params.height);
    }

    function draw(tilebox, ix, iy) {
      context.drawImage(
          tilebox.tile.img,  // Image to read, and paint to the canvas
          tilebox.sx,        // First x-pixel in tile to read
          tilebox.sy,        // First y-pixel in tile to read
          tilebox.sw,        // Number of pixels to read in x
          tilebox.sw,        // Number of pixels to read in y
          ix * size,         // First x-pixel in canvas to paint
          iy * size,         // First y-pixel in canvas to paint
          size,              // Number of pixels to paint in x
          size               // Number of pixels to paint in y
          );
      return;
    }
  }

  // Creates a distance metric function that indicates, for a given tile
  // specified by z, x, y indices, how far away it is from the current grid
  function initTileMetric(params, getZXY) {
    const zxy = [];

    return function(z, x, y) {
      getZXY(zxy, 0, 0);  // Get indices of the tile at the top left corner
      let nTiles = 2 ** zxy[0];

      // Find edges of tile and map, in units of tiles at current map zoom
      var zoomFac = 2 ** (zxy[0] - z);
      var tile = {
        x1: x * zoomFac,
        x2: (x + 1) * zoomFac,
        y1: y * zoomFac,
        y2: (y + 1) * zoomFac,
      };
      var map = {
        x1: zxy[1],
        x2: zxy[1] + params.nx + 1, // Note: may extend across antimeridian!
        y1: zxy[2],
        y2: zxy[2] + params.ny + 1, // Note: may extend across a pole!
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      //             where a "tile" is measured at map zoom level

      // Note: need to be careful with distances crossing an antimeridian or pole
      var xdist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.x1 - tile.x2, tile.x1 - map.x2),
          // Re-test with tile shifted across antimeridian 
          Math.max(map.x1 - (tile.x2 + nTiles), (tile.x1 + nTiles) - map.x2)
          );
      var ydist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.y1 - tile.y2, tile.y1 - map.y2),
          // Re-test with tile shifted across pole 
          Math.max(map.y1 - (tile.y2 + nTiles), (tile.y1 + nTiles) - map.y2)
          );
      // Use the largest distance
      var hdist = Math.max(xdist, ydist);

      // Adjust for zoom difference
      return hdist - 1.0 + 1.0 / zoomFac;
    }
  }

  function init(userParams) {
    const params = setParams(userParams);
    const getTile = userParams.getTile;
    if (!params) return;

    const coords = initTileCoords(params);
    const renderer = initRenderer(params);

    const oneTileComplete = 1. / params.nx / params.ny;
    var complete = 0.0;

    const boxes = Array.from(Array(params.ny), () => []);

    return {
      canvas: params.context.canvas,

      // Report status or data
      loaded: () => complete,
      getTilePos,
      // Methods to clear or update the canvas
      reset,
      clear,
      drawTiles,

      // Coordinate methods to set the position and zoom of the map
      move:       (dz, dx, dy) => { if (coords.move(dz, dx, dy))       clear(); },
      fitBoundingBox: (p1, p2) => { if (coords.fitBoundingBox(p1, p2)) clear(); },
      setCenterZoom:    (c, z) => { if (coords.setCenterZoom(c, z))    clear(); },

      // Methods to convert coordinates, or report conversion parameters
      toLocal:       coords.toLocal,
      xyToMapPixels: coords.xyToMapPixels,
      getScale:      coords.getScale,

      // Metric to evaluate distance of a tile from the current grid
      tileDistance: initTileMetric(params, coords.getZXY),
    };

    function getTilePos(mapXY) {
      // Get indices to the tile box
      let fx = mapXY[0] / params.tileSize;
      let fy = mapXY[1] / params.tileSize;
      let ix = Math.floor(fx);
      let iy = Math.floor(fy);

      // Get the tile box itself
      let box = (boxes[iy]) ? boxes[iy][ix] : undefined;
      if (!box) return;

      // Compute position and scaling within the tile
      let x = (fx - ix) * box.sw + box.sx;
      let y = (fy - iy) * box.sw + box.sy;
      let frac = box.sw / params.tileSize; // Fraction of the tile being used

      // Return the tile along with the projected position and scaling info
      return { x, y, frac, tile: box.tile };
    }

    function reset() {
      boxes.forEach(row => { row.length = 0; });
      complete = 0.0;
    }
    function clear() { // TODO: Do we ever need reset without clear?
      reset();
      renderer.clear();
    }

    function drawTiles() {
      var updated = false;
      if (complete === 1.0) return updated; // Map is complete, no change!
      const zxy = [];

      for (let iy = 0; iy < params.ny; iy++) {
        var row = boxes[iy];
        for (let ix = 0; ix < params.nx; ix++) {
          coords.getZXY(zxy, ix, iy);
          var currentZ = (row[ix]) 
            ? row[ix].tile.z
            : undefined;
          if (currentZ === zxy[0]) continue; // This tile already done

          var newbox = getTile( zxy );
          if (!newbox) continue; // No image available for this tile
          if (newbox.tile.z === currentZ) continue; // Tile already written

          row[ix] = newbox;
          renderer.draw(newbox, ix, iy);
          updated = true;

          if (newbox.tile.z === zxy[0]) complete += oneTileComplete;
        }
      }
      return updated;
    }
  }

  function initMapArray(mapParams, numLevels) {
    const maps = [];
    for (let i = 0; i < numLevels; i++) {
      maps[i] = initFrame(mapParams);
    }

    return {
      textures: maps.map( map => map.texture ),
      loaded: () => maps.reduce( (sum, map) => sum + map.frame.loaded(), 0 ),

      setCenterZoom,
      drawTiles,
      tileDistance,
    };

    function drawTiles() {
      maps.forEach( map => { map.texture.changed = map.frame.drawTiles(); });
    }

    function setCenterZoom(center, zoom) {
      maps.forEach( (map, index) => {
        // Set increasing zoom levels, up to last map with z = zoom
        let z = zoom - numLevels + index + 1;
        map.frame.setCenterZoom(center, z);

        // Update texture coordinate transform parameters
        map.frame.toLocal(map.texture.camPos, center);
        map.texture.scale[0] = map.frame.getScale(0);
        map.texture.scale[1] = map.frame.getScale(1);
      });
    }

    function tileDistance(z, x, y) {
      let distances = maps.map( map => map.frame.tileDistance(z, x, y) );
      return Math.min(...distances);
    }
  }

  function initFrame(mapParams) {
    const frame = init(mapParams);
    const texture = {
      canvas: frame.canvas,
      camPos: new Float64Array(2),
      scale: new Float64Array(2),
      changed: true,
    };
    return { frame, texture };
  }

  function initMaps(mapParams) {
    // Wrapper for maps. Handles projection of spherical coordinates
    const xy = new Float64Array(2);
    const tileSize = mapParams.tileSize;

    const cache = initRasterCache(tileSize, tileURL);
    var numCachedTiles = 0;

    // Initialize array of 2D map grids
    mapParams.getTile = cache.retrieve;
    const maps = initMapArray(mapParams, 2);

    return {
      textures: maps.textures,
      loaded: maps.loaded,

      setPosition,
      draw,
    };

    function setPosition(camPos, radius, view) {
      // Get map zoom
      let dMap = camPos[2] / radius *        // Normalize to radius = 1
        view.topEdge() * 2 / view.height() * // ray tangent per pixel
        scale(camPos);            // Scale assumes sphere radius = 1
      let zoom = Math.round( -Math.log2(tileSize * dMap) );

      lonLatToXY(xy, camPos);
      maps.setCenterZoom(xy, zoom);
    }

    function draw() {
      maps.drawTiles();
      numCachedTiles = cache.trim(maps.tileDistance, 1.5);
    }
  }

  function tileURL(z, x, y) {
    const endpoint = "http://tile.stamen.com/toner-lite/{z}/{x}/{y}.png";
    return endpoint.replace(/{z}/, z).replace(/{x}/, x).replace(/{y}/, y);
  }

  // Fill a supplied DIV with a background Canvas for rendering
  function addCanvas(parentElement) {
    var child = document.createElement('canvas');
    // Could use Object.assign, but not supported by Android Webview?
    setStyles(child, {
      "width": "100%",
      "height": "100%",
      "display": "inline-block",
      "position": "absolute",
      "top": 0,
      "left": 0,
      "z-index": 0,
    });
    parentElement.appendChild(child);
    return child;
  }

  function setStyles(element, styles) {
    Object.keys(styles).forEach(key => {
      element.style[key] = styles[key];
    });
    return element;
  }

  function createAttributeSetters(gl, program) {
    // Very similar to greggman's module:
    // https://github.com/gfxfundamentals/webgl-fundamentals/blob/master/
    //  webgl/resources/webgl-utils.js
    var attribSetters = {};
    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttribs; i++) {
      var attribInfo = gl.getActiveAttrib(program, i);
      if (!attribInfo) break;
      var index = gl.getAttribLocation(program, attribInfo.name);
      attribSetters[attribInfo.name] = createAttribSetter(gl, index);
    }
    return attribSetters;
  }

  function createAttribSetter(gl, index) {
    return function(b) {
      // Enable this attribute (shader attributes are disabled by default)
      gl.enableVertexAttribArray(index);
      // Bind the buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
      // Point the attribute in the program to this buffer,
      // and tell the program the byte layout in the buffer
      gl.vertexAttribPointer(
          index,                      // index of attribute in program
          b.numComponents || b.size,  // Number of elements to read per vertex
          b.type || gl.FLOAT,         // Type of each element
          b.normalize || false,       // Whether to normalize it
          b.stride || 0,              // Byte spacing between vertices
          b.offset || 0               // Byte # to start reading from
          );
    };
  }

  function setBuffersAndAttributes(gl, setters, buffers) {
    setAttributes(setters, buffers.attributes);
    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices.buffer);
    }
  }

  function setAttributes(setters, attribs) {
    Object.keys(attribs).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter( attribs[name] );
    });
  }

  function createUniformSetters(gl, program) {
    // Very similar to greggman's module:
    // https://github.com/greggman/webgl-fundamentals/blob/master/webgl/resources/webgl-utils.js

    var uniformSetters = {};
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    // Track texture bindpoint index in case multiple textures are required
    var textureUnit = 0;

    for (let i = 0; i < numUniforms; i++) {
      var uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) break;

      var name = uniformInfo.name;
      // remove the array suffix added by getActiveUniform
      if (name.substr(-3) === "[0]") name = name.substr(0, name.length - 3);

      var setter = createUniformSetter(program, uniformInfo);
      uniformSetters[name] = setter;
    }
    return uniformSetters;

    // This function must be nested to access the textureUnit index
    function createUniformSetter(program, uniformInfo) {
      var loc = gl.getUniformLocation(program, uniformInfo.name);
      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
      var type = uniformInfo.type;
      switch (type) {
        case gl.FLOAT:
          return (isArray)
            ? (v) => gl.uniform1fv(loc, v)
            : (v) => gl.uniform1f(loc, v);
        case gl.FLOAT_VEC2:
          return (v) => gl.uniform2fv(loc, v);
        case gl.FLOAT_VEC3:
          return (v) => gl.uniform3fv(loc, v);
        case gl.FLOAT_VEC4:
          return (v) => gl.uniform4fv(loc, v);
        case gl.INT:
          return (isArray)
            ? (v) => gl.uniform1iv(loc, v)
            : (v) => gl.uniform1i(loc, v);
        case gl.INT_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.INT_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.INT_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.BOOL:
          return (v) => gl.uniform1iv(loc, v);
        case gl.BOOL_VEC2:
          return (v) => gl.uniform2iv(loc, v);
        case gl.BOOL_VEC3:
          return (v) => gl.uniform3iv(loc, v);
        case gl.BOOL_VEC4:
          return (v) => gl.uniform4iv(loc, v);
        case gl.FLOAT_MAT2:
          return (v) => gl.uniformMatrix2fv(loc, false, v);
        case gl.FLOAT_MAT3:
          return (v) => gl.uniformMatrix3fv(loc, false, v);
        case gl.FLOAT_MAT4:
          return (v) => gl.uniformMatrix4fv(loc, false, v);
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          if (isArray) {
            var units = [];
            for (let i = 0; i < uniformInfo.size; i++) {
              units.push(textureUnit++);
            }
            return function(bindPoint, units) {
              return function(textures) {
                gl.uniform1iv(loc, units);
                textures.forEach( function(texture, index) {
                  gl.activeTexture(gl.TEXTURE0 + units[index]);
                  gl.bindTexture(bindPoint, texture);
                });
              };
            }(getBindPointForSamplerType(gl, type), units);
          } else {
            return function(bindPoint, unit) {
              return function(texture) {
                //gl.uniform1i(loc, units); // Typo? How did it even work?
                gl.uniform1i(loc, unit);
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(bindPoint, texture);
              };
            }(getBindPointForSamplerType(gl, type), textureUnit++);
          }
       default:  // we should never get here
          throw("unknown type: 0x" + type.toString(16));
      }
    }
  }

  function getBindPointForSamplerType(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;
    return undefined;
  }

  function setUniforms(setters, values) {
    Object.keys(values).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter(values[name]);
    });
  }

  // Initialize a shader program
  function initShaderProgram(gl, vsSource, fsSource) {
    // NOTE: Load any WebGL extensions before calling this

    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert( 'Unable to initialize the shader program: \n' +
          gl.getProgramInfoLog(shaderProgram) );
      // This is not very good error handling... should be returning the error
      return null;
    }

    return {
      program: shaderProgram,
      attributeSetters: createAttributeSetters(gl, shaderProgram),
      uniformSetters: createUniformSetters(gl,shaderProgram),
    };
  }

  // create shader of a given type, upload source, compile it
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type); // no error handling??

    // Send the source to the shader object
    gl.shaderSource(shader, source);

    // Compile the shader program
    gl.compileShader(shader);

    // Now check for errors
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      // this alert business is sloppy...
      alert( 'An error occurred compiling the shaders: \n' +
          gl.getShaderInfoLog(shader) );
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  function drawScene(gl, programInfo, bufferInfo, uniforms, viewport) {
    // Make a blank canvas that fills the displayed size from CSS
    prepCanvas(gl, viewport);

    // Tell WebGL to use our program when drawing
    gl.useProgram(programInfo.program);

    // Prepare shader attributes.
    setBuffersAndAttributes( gl, programInfo.attributeSetters, bufferInfo );
    // Set the shader uniforms
    setUniforms( programInfo.uniformSetters, uniforms );

    // Draw the scene
    gl.drawElements(gl.TRIANGLES, bufferInfo.indices.vertexCount,
        bufferInfo.indices.type, bufferInfo.indices.offset);

    // Turn off the scissor test for now  TODO: is this necessary?
    gl.disable(gl.SCISSOR_TEST);
  }

  function prepCanvas(gl, port) {
    // Set some parameters
    gl.clearColor(0.0, 0.0, 0.0, 0.0);  // Clear to transparent black
    gl.clearDepth(1.0);                 // Clear everything
    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

    // Tell WebGL how to convert from clip space to pixels
    if (port !== undefined) {
      gl.viewport(port.left, port.bottom, port.width, port.height);
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(port.left, port.bottom, port.width, port.height);
    } else {
      // Use the whole canvas
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }

    // Clear the canvas AND the depth buffer
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    return;
  }

  // Make sure the canvas drawingbuffer is the same size as the display
  // webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
  function resizeCanvasToDisplaySize(canvas) {
    let width = canvas.clientWidth;
    let height = canvas.clientHeight;
    if (canvas.width !== width || canvas.height !== height) {
      // Resize drawingbuffer to match resized display
      canvas.width = width;
      canvas.height = height;
      return true;
    }
    return false;
  }

  function initQuadBuffers(gl) {
    // 4 vertices at the corners of the quad
    const vertices = [ -1, -1,  0,    1, -1,  0,    1,  1,  0,   -1,  1,  0 ];
    // Store byte info and load into GPU
    const vertexPositions = {
      buffer: gl.createBuffer(),
      numComponents: 3,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    // Bind to the gl context
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositions.buffer);
    // Pass the array into WebGL
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Texture coordinates assume image has 0,0 at top left
    const texCoordData = [ 0, 1,   1, 1,   1, 0,   0, 0 ];
    const texCoords = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoords.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoordData), gl.STATIC_DRAW);

    // Index into two triangles
    var indices = [ 0,  1,  2,    2,  3,  0 ];
    const vertexIndices = {
      buffer: gl.createBuffer(),
      vertexCount: indices.length,
      type: gl.UNSIGNED_SHORT,
      offset: 0
    };
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndices.buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    return {
      attributes: {
        aVertexPosition: vertexPositions,
        aTexCoord: texCoords,
      },
      indices: vertexIndices,
    };
  }

  function setupMipMaps(gl, target, width, height) {
    // We are using WebGL1 (for compatibility with mobile browsers) which can't
    // handle mipmapping for non-power-of-2 images. Maybe we should provide
    // pre-computed mipmaps? see https://stackoverflow.com/a/21540856/10082269
    if (isPowerOf2(width) && isPowerOf2(height)) {
      gl.generateMipmap(target);
      // Clamp to avoid wrapping around poles
      // TODO: this may not work with circular coordinates?
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    } else { // Turn off mipmapping 
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // Set wrapping to clamp to edge
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    return;
  }

  function setTextureAnisotropy(gl, target) {
    var ext = (
        gl.getExtension('EXT_texture_filter_anisotropic') ||
        gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || 
        gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        );
    if (ext) {
      var maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      // BEWARE: this texParameterf call is slow on Intel integrated graphics.
      // Avoid this entire function if at all possible.
      gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, 
          maxAnisotropy);
    }
    return;
  }

  function isPowerOf2(value) {
    // This trick uses bitwise operators.
    // See https://stackoverflow.com/a/30924333/10082269
    return value && !(value & (value - 1));
    // For a better explanation, with some errors in the solution, see
    // https://stackoverflow.com/a/30924360/10082269
  }

  function initTexture(gl, width, height) {
    // Initializes a 2D texture object, extending the default gl.createTexture()
    // The GL context and the binding target are implicitly saved in the closure.
    // Returns the sampler (as a property) along with update and replace methods.
    // Input data is an ImageData object

    const target = gl.TEXTURE_2D;
    const texture = gl.createTexture();
    gl.bindTexture(target, texture);

    // Initialize with default parameters
    const level = 0;  // Mipmap level
    const internalFormat = gl.RGBA;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;
    const border = 0;

    gl.texImage2D(target, level, internalFormat, width, height, border,
        srcFormat, srcType, null);

    // Set up mipmapping and anisotropic filtering, if appropriate
    setupMipMaps(gl, target, width, height);
    setTextureAnisotropy(gl, target);

    return {
      sampler: texture,
      replace,
      update,
    }

    function replace( image ) {
      // Replaces the texture with the supplied image data
      // WARNING: will change texture width/height to match the image
      gl.bindTexture(target, texture);
      gl.texImage2D(target, level, internalFormat, srcFormat, srcType, image);

      // Re-do mipmap setup, since width/height may have changed
      setupMipMaps(gl, target, image.width, image.height);
      return;
    }

    function update( image ) {
      // Updates a portion of the texture with the supplied image data.
      gl.bindTexture(target, texture);

      // Image will be written starting from the pixel (xoffset, yoffset).
      // If these values are not set on the input, use (0,0)
      var xoff = image.xoffset || 0;
      var yoff = image.yoffset || 0;
      gl.texSubImage2D(target, level, xoff, yoff, srcFormat, srcType, image);

      setupMipMaps(gl, target, image.width, image.height);
      return;
    }
  }

  var vertexSrc = `attribute vec4 aVertexPosition;
uniform vec2 uMaxRay;

varying highp vec2 vRayParm;

void main(void) {
  vRayParm = uMaxRay * aVertexPosition.xy;
  gl_Position = aVertexPosition;
}
`;

  var invertSrc = `uniform float uLat0;
uniform float uCosLat0;
uniform float uSinLat0;
uniform float uTanLat0;

float latChange(float x, float y, float sinC, float cosC) {
  float xtan = x * uTanLat0;
  float curveTerm = 0.5 * y * (xtan * xtan - y * y / 3.0);

  return (max(sinC, abs(sinC * uTanLat0) ) < 0.1)
    ? sinC * (y - sinC * (0.5 * xtan * x + curveTerm * sinC))
    : asin(uSinLat0 * cosC + y * uCosLat0 * sinC) - uLat0;
}

vec2 xyToLonLat(vec2 xy, float sinC, float cosC) {
  vec2 pHat = normalize(xy);
  float dLon = atan(pHat.x * sinC,
      uCosLat0 * cosC - pHat.y * uSinLat0 * sinC);
  float dLat = latChange(pHat.x, pHat.y, sinC, cosC);
  return vec2(dLon, dLat);
}
`;

  var projectSrc = `const float ONEOVERTWOPI = 0.15915493667125702;

uniform float uExpY0;
uniform float uLatErr; // Difference of clipping to map limit

float smallTan(float x) {
  return (abs(x) < 0.1)
    ? x * (1.0 + x * x / 3.0)
    : tan(x);
}

float log1plusX(float x) {
  return (abs(x) < 0.15)
    ? x * (1.0 - x * (0.5 - x / 3.0 + x * x / 4.0))
    : log( 1.0 + max(x, -0.999) );
}

vec2 projMercator(vec2 dLonLat) {
  float tandlat = smallTan( 0.5 * (dLonLat[1] + uLatErr) );
  float p = tandlat * uExpY0;
  float q = tandlat / uExpY0;
  return vec2(dLonLat[0], log1plusX(-p) - log1plusX(q)) * ONEOVERTWOPI;
}
`;

  var texLookup = `uniform sampler2D uTextureSampler[nLod];
uniform vec2 uCamMapPos[nLod];
uniform vec2 uMapScales[nLod];

float dateline(float x1) {
  // Choose the correct texture coordinate in fragments crossing the
  // antimeridian of a cylindrical coordinate system
  // See http://vcg.isti.cnr.it/~tarini/no-seams/

  // Alternate coordinate: forced across the antimeridian
  float x2 = fract(x1 + 0.5) - 0.5;
  // Choose the coordinate with the smaller screen-space derivative
  return (fwidth(x1) < fwidth(x2) + 0.001) ? x1 : x2;
}

//bool inside(vec2 pos) {
  // Check if the supplied texture coordinate falls inside [0,1] X [0,1]
  // We adjust the limits slightly to ensure we are 1 pixel away from the edges
//  return (
//      0.001 < pos.x && pos.x < 0.999 &&
//      0.001 < pos.y && pos.y < 0.999 );
//}

vec4 texLookup(vec2 dMerc) {
  vec2 texCoords[nLod];

  for (int i = 0; i < nLod; i++) {
    texCoords[i] = uCamMapPos[i] + uMapScales[i] * dMerc;
    texCoords[i].x = dateline(texCoords[i].x);
  }

  return sampleLOD(uTextureSampler, texCoords);
}
`;

  var dither2x2 = `float threshold(float val, float limit) {
  float decimal = fract(255.0 * val);
  float dithered = (decimal < limit)
    ? 0.0
    : 1.0;
  float adjustment = (dithered - decimal) / 255.0;
  return val + adjustment;
}

vec3 dither2x2(vec2 position, vec3 color) {
  // Based on https://github.com/hughsk/glsl-dither/blob/master/2x2.glsl
  int x = int( mod(position.x, 2.0) );
  int y = int( mod(position.y, 2.0) );
  int index = x + y * 2;

  float limit = 0.0;
  if (index == 0) limit = 0.25;
  if (index == 1) limit = 0.75;
  if (index == 2) limit = 1.00;
  if (index == 3) limit = 0.50;

  // Use limit to toggle color between adjacent 8-bit values
  return vec3(
      threshold(color.r, limit),
      threshold(color.g, limit),
      threshold(color.b, limit)
      );
}
`;

  var fragMain = `float diffSqrt(float x) {
  // Returns 1 - sqrt(1-x), with special handling for small x
  float halfx = 0.5 * x;
  return (x < 0.1)
    ? halfx * (1.0 + 0.5 * halfx * (1.0 + halfx))
    : 1.0 - sqrt(1.0 - x);
}

float horizonTaper(float gamma) {
  // sqrt(gamma) = tan(ray_angle) / tan(horizon)
  float horizonRatio = sqrt(gamma);
  float delta = 2.0 * fwidth(horizonRatio);
  return 1.0 - smoothstep(1.0 - delta, 1.0, horizonRatio);
}

varying vec2 vRayParm;
uniform float uHnorm;

void main(void) {
  // 0. Pre-compute some values
  float p = length(vRayParm); // Tangent of ray angle
  float p2 = p * p;
  float gamma = p2 * uHnorm * (2.0 + uHnorm);
  float sinC = (uHnorm + diffSqrt(gamma)) * p / (1.0 + p2);
  float cosC = sqrt(1.0 - sinC * sinC);

  // 1. Invert for longitude and latitude perturbations relative to camera
  vec2 dLonLat = xyToLonLat(vRayParm, sinC, cosC);

  // 2. Project to a change in the Mercator coordinates
  vec2 dMerc = projMercator(dLonLat);

  // 3. Lookup color from the appropriate texture
  vec4 texelColor = texLookup(dMerc);

  // Add cosine shading, dithering, and horizon tapering
  vec3 dithered = dither2x2(gl_FragCoord.xy, cosC * texelColor.rgb);
  gl_FragColor = vec4(dithered.rgb, texelColor.a) * horizonTaper(gamma);
}
`;

  const header = `
#extension GL_OES_standard_derivatives : enable
precision highp float;
precision highp sampler2D;

`;

  function buildShader(nLod) {
    nLod = Math.max(1, Math.floor(nLod));
    const lodSrc = insideSrc + setupLOD(nLod) + texLookup;

    const fragmentSrc = header + invertSrc + projectSrc + 
      lodSrc + dither2x2 + fragMain;

    return {
      vert: vertexSrc,
      frag: fragmentSrc,
    };
  }

  function setupLOD(nLod) {
    // Define function signature, with pre-defined constant
    var selector = `const int nLod = ${nLod};
vec4 sampleLOD(sampler2D samplers[${nLod}], vec2 coords[${nLod}]) {
  return `;

    // Sample from the highest LOD that includes the coordinate
    for (let i = nLod - 1; i > 0; i--) {
      selector += `inside(coords[${i}])
    ? texture2D(samplers[${i}], coords[${i}])
    : `;
    }
    // Add default to lowest LOD
    selector += `texture2D(samplers[0], coords[0]);`;

    // Close the function block: bracket AND line break
    selector += `
}
`;
    return selector;
  }

  const insideSrc = `
bool inside(vec2 pos) {
  // Check if the supplied texture coordinate falls inside [0,1] X [0,1]
  // We adjust the limits slightly to ensure we are 1 pixel away from the edges
  return (
      0.001 < pos.x && pos.x < 0.999 &&
      0.001 < pos.y && pos.y < 0.999 );
}
`;

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat$1 = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function getWebMercatorFactors(camLatitude) {
    // Clip latitude to map limits
    var clipLat = Math.min(Math.max(-maxMercLat$1, camLatitude), maxMercLat$1);
    var latErr = camLatitude - clipLat;

    // camera exp(Y), for converting delta latitude to delta Y
    var expY = Math.tan( 0.25 * Math.PI + 0.5 * clipLat );

    return [expY, latErr];
  }

  const nMaps = 2; // NOTE: Also hard-coded in shader!

  function initSatelliteView(container, radius, mapWidth, mapHeight) {
    // Input container is an HTML element that will be filled with a canvas
    //  on which will the view will be rendered
    // Input radius is the (floating point) radius of the spherical Earth
    // Input mapWidth, mapHeight are the pixel dimensions of the maps that
    //  will be supplied to the draw function.

    const canvas = addCanvas(container);
    const gl = canvas.getContext("webgl");
    gl.getExtension('OES_standard_derivatives');

    // Initialize shader program
    const shaders = buildShader(nMaps);
    console.log(shaders.frag);
    const progInfo = initShaderProgram(gl, shaders.vert, shaders.frag);

    // Load data into GPU for shaders: attribute buffers, indices, textures
    const buffers = initQuadBuffers(gl);
    const textureMaker = () => initTexture(gl, mapWidth, mapHeight);
    const textures = Array.from(Array(nMaps), textureMaker);

    // Store links to uniform arrays
    const uniforms = {
      uMaxRay: new Float64Array(2),
      uTextureSampler: textures.map(tx => tx.sampler),
      uCamMapPos: new Float64Array(2 * nMaps),
      uMapScales: new Float64Array(2 * nMaps),
    };

    return {
      canvas,
      draw,
    };

    function draw(maps, camPos, maxRayTan, camMoving) {
      if (maps.length !== nMaps) {
        return console.log("ERROR in renderer.draw: maps array length is wrong!");
      }
      if (!camMoving && !maps.some(map => map.changed)) return;

      // Update uniforms related to camera position
      uniforms.uHnorm = camPos[2] / radius;
      uniforms.uLat0 = camPos[1];
      uniforms.uCosLat0 = Math.cos(camPos[1]);
      uniforms.uSinLat0 = Math.sin(camPos[1]);
      uniforms.uTanLat0 = Math.tan(camPos[1]);
      [uniforms.uExpY0, uniforms.uLatErr] = getWebMercatorFactors(camPos[1]);

      uniforms.uMaxRay.set(maxRayTan);

      // Set uniforms and update textures for each map
      maps.forEach( (map, index) => {
        uniforms.uCamMapPos.set(map.camPos, 2 * index);
        uniforms.uMapScales.set(map.scale, 2 * index);
        if (map.changed) textures[index].update(map.canvas);
      });

      // Draw the globe
      resizeCanvasToDisplaySize(canvas);
      drawScene(gl, progInfo, buffers, uniforms);
    }
  }

  const degrees = 180.0 / Math.PI;

  const mapParams = {
    tileSize: 256,
    maxZoom: 23,
    width: 1024,
    height: 1024,
  };
  const radius = 6371;

  function main() {
    var maps, requestID;
    const camPosition = new Float64Array(3);

    // Get links to lon/lat/alt inputs and display div
    const coordInput = document.getElementById("coordInput");
    const container = document.getElementById("globe");
    const view = initView(container, 25.0);

    // Setup coordinates interaction
    maps = initMaps(mapParams);

    const renderer = initSatelliteView(
      container, 
      radius,
      mapParams.width, 
      mapParams.height);

    coordInput.addEventListener("input", getCoords, false);
    getCoords();

    function getCoords() {
      let coords = coordInput.elements;
      camPosition[0] = coords["lon"].value / degrees;
      camPosition[1] = coords["lat"].value / degrees;
      camPosition[2] = coords["alt"].value;

      // Start a rendering loop. Cancel running loops to avoid memory leaks
      cancelAnimationFrame(requestID);
      requestID = requestAnimationFrame(animate);
    }

    function animate(time) {
      let resized = view.changed();
      maps.setPosition(camPosition, radius, view);
      maps.draw();
      renderer.draw(maps.textures, camPosition, view.maxRay, true);

      if (maps.loaded() < 2.0) requestAnimationFrame(animate);
    }
  }

  exports.main = main;

  return exports;

}({}));
